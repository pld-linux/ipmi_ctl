--- ipmi-ctl-2.0.orig/Makefile
+++ ipmi-ctl-2.0/Makefile
@@ -1,16 +1,19 @@
-CFLAGS 		= -I. -g
+CFLAGS 		= -I. -g -O2
 LDFLAGS		= -lm
 SPEC_FILE	= ipmi_ctl.spec
 		
 OBJS		= ipmi_ctl.o sdr.o sel.o
 
-all: ipmi_ctl
+all: ipmi_ctl dmidecode
 
 ipmi_ctl: $(OBJS)
 	$(CC) -o ipmi_ctl $(LDFLAGS) $(OBJS) 
 
+dmidecode: dmidecode.c
+	$(CC) $(CFLAGS) -o dmidecode dmidecode.c
+
 clean:
-	rm -f $(OBJS) ipmi_ctl
+	rm -f $(OBJS) ipmi_ctl dmidecode dmidecode.o
 
 install: ipmi_ctl
 	mkdir -p $(PREFIX)/sbin/
--- ipmi-ctl-2.0.orig/sdr.h
+++ ipmi-ctl-2.0/sdr.h
@@ -465,4 +465,8 @@
 #define CMD_GET_SDR_REPOSITORY_TIME       0x28
 #define CMD_GET_SENSOR_READING            0x2D
 
+char *sensor_get_type(unsigned char sensor_type_code);
+char *sensor_get_trigger_description(unsigned char sensor_reading_type_code,
+                                   unsigned char offset);
+
 #endif
--- ipmi-ctl-2.0.orig/ipmi_ctl.c
+++ ipmi-ctl-2.0/ipmi_ctl.c
@@ -2,7 +2,7 @@
 #include <sys/types.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <linux/ipmi_ioctls.h>
+#include "ipmi_ioctls.h"
 #include <ipmi_ctl.h>
 #include <sdr.h>
 #include <sensor_events.h>
@@ -22,7 +22,7 @@
 int set_asset(int fd, char *asset_tag);
 int set_blink(int fd, int state);
 void display_fru(void);
-void usage(char *progname);
+void usage(const char *progname);
 void display_sensor_list();
 
 DEVICE_ID_RESPONSE	dev_id;
@@ -38,15 +38,19 @@
 	int	fd, rc;
 	int	mode = 0;
 
-	if ((fd = open("/dev/ipmi/kcs", O_RDWR))<0)
+	if (((fd = open("/dev/ipmikcs", O_RDWR))==-1) && (errno==ENOENT))
+		fd = open("/dev/misc/ipmi_kcs", O_RDWR);
+
+	if (fd == -1)
 		{
-		perror("open");
-		exit(-1);
+		perror("Error opening IPMI-KCS device");
+		exit(1);
 		}
 	if (argc < 2)
 		{
+		fprintf(stderr, "Not enough options given\n");
 		usage(argv[0]);
-		exit(-1);
+		exit(1);
 		}
 	printf("IPMI CTL Version 2.0, (c) 2001 San Mehat (nettwerk@valinux.com)\n");
 	report_device_id(fd);
@@ -769,7 +773,7 @@
 /*
  * General Purpose stuff
  */
-void usage(char *progname)
+void usage(const char *progname)
 {
 	printf("Usage: %s [-r] [-s] [-p] [-d]\n",progname);
 	printf("       -r         -- report mainboard device ID\n");
--- ipmi-ctl-2.0.orig/sdr.c
+++ ipmi-ctl-2.0/sdr.c
@@ -2,7 +2,7 @@
 #include <fcntl.h>
 #include <errno.h>
 #include <sys/types.h>
-#include <linux/ipmi_ioctls.h>
+#include "ipmi_ioctls.h"
 #include <sdr.h>
 #include <sensor_events.h>
 #include <math.h>
--- ipmi-ctl-2.0.orig/sel.c
+++ ipmi-ctl-2.0/sel.c
@@ -2,7 +2,7 @@
 #include <fcntl.h>
 #include <errno.h>
 #include <sys/types.h>
-#include <linux/ipmi_ioctls.h>
+#include "ipmi_ioctls.h"
 #include <sdr.h>
 #include <sel.h>
 #include <sensor_events.h>
--- ipmi-ctl-2.0.orig/dmidecode.c
+++ ipmi-ctl-2.0/dmidecode.c
@@ -0,0 +1,479 @@
+/*
+ *	DMI decode rev 1.1
+ *
+ *	(C) 2000,2001 Alan Cox <alan@redhat.com>
+ *
+ *	Licensed under the GNU Public license. If you want to use it in with
+ *	another license just ask.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+#include <stdlib.h>
+
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+
+struct dmi_header
+{
+	u8	type;
+	u8	length;
+	u16	handle;
+};
+
+static char *dmi_string(struct dmi_header *dm, u8 s)
+{
+	u8 *bp=(u8 *)dm;
+	bp+=dm->length;
+	while(s>1)
+	{
+		bp+=strlen(bp);
+		bp++;
+		s--;
+	}
+	return bp;
+}
+
+static void dmi_decode_ram(u8 data)
+{
+	if(data&(1<<0))
+		printf("OTHER ");
+	if(data&(1<<1))
+		printf("UNKNOWN ");
+	if(data&(1<<2))
+		printf("STANDARD ");
+	if(data&(1<<3))
+		printf("FPM ");
+	if(data&(1<<4))
+		printf("EDO ");
+	if(data&(1<<5))
+		printf("PARITY ");
+	if(data&(1<<6))
+		printf("ECC ");
+	if(data&(1<<7))
+		printf("SIMM ");
+	if(data&(1<<8))
+		printf("DIMM ");
+	if(data&(1<<9))
+		printf("Burst EDO ");
+	if(data&(1<<10))
+		printf("SDRAM ");
+}
+
+static void dmi_cache_size(u16 n)
+{
+	if(n&(1<<15))
+		printf("%dK\n", (n&0x7FFF)*64);
+	else
+		printf("%dK\n", n&0x7FFF);
+}
+
+static void dmi_decode_cache(u16 c)
+{
+	if(c&(1<<0))
+		printf("Other ");
+	if(c&(1<<1))
+		printf("Unknown ");
+	if(c&(1<<2))
+		printf("Non-burst ");
+	if(c&(1<<3))
+		printf("Burst ");
+	if(c&(1<<4))
+		printf("Pipeline burst ");
+	if(c&(1<<5))
+		printf("Synchronous ");
+	if(c&(1<<6))
+		printf("Asynchronous ");
+}
+
+static char *dmi_bus_name(u8 num)
+{
+	static char *bus[]={
+		"",
+		"",
+		"",
+		"ISA ",
+		"MCA ",
+		"EISA ",
+		"PCI ",
+		"PCMCIA "
+		"VLB ",
+		"Proprietary ",
+		"CPU Slot ",
+		"Proprietary RAM ",
+		"I/O Riser ",
+		"NUBUS ",
+		"PCI-66 ",
+		"AGP ",
+		"AGP 2x ",
+		"AGP 4x "
+	};
+	static char *jpbus[]={
+		"PC98/C20",
+		"PC98/C24",
+		"PC98/E",
+		"PC98/LocalBus",
+		"PC98/Card"
+	};
+	
+	if(num<=0x12)
+		return bus[num];
+	if(num>=0xA0 && num<0xA5)
+		return jpbus[num];
+	return "";
+}
+
+static char *dmi_bus_width(u8 code)
+{
+	static char *width[]={
+		"",
+		"",
+		"",
+		"8bit ",
+		"16bit ",
+		"32bit ",
+		"64bit ",
+		"128bit "
+	};
+	if(code>7)
+		return "";
+	return width[code];
+}
+
+static char *dmi_card_size(u8 v)
+{
+	if(v==2)
+		return("Short ");
+	if(v==3)
+		return("Long ");
+	return "";
+}
+
+static void dmi_card_props(u8 v)
+{
+	printf("\t\tSlot Features: ");
+	if(v&(1<<1))
+		printf("5v ");
+	if(v&(1<<2))
+		printf("3.3v ");
+	if(v&(1<<3))
+		printf("Shared ");
+	if(v&(1<<4))
+		printf("PCCard16 ");
+	if(v&(1<<5))
+		printf("CardBus ");
+	if(v&(1<<6))
+		printf("Zoom-Video ");
+	if(v&(1<<7))
+		printf("ModemRingResume ");
+	printf("\n");
+}		
+		
+		
+static void dmi_table(int fd, u32 base, int len, int num)
+{
+	char *buf=malloc(len);
+	struct dmi_header *dm;
+	u8 *data;
+	int i=0;
+		
+	if(lseek(fd, (long)base, 0)==-1)
+	{
+		perror("dmi: lseek");
+		return;
+	}
+	if(read(fd, buf, len)!=len)
+	{
+		perror("dmi: read");
+		return;
+	}
+	data = buf;
+	while(i<num)
+	{
+		u32 u;
+		u32 u2;
+		dm=(struct dmi_header *)data;
+		printf("Handle 0x%04X\n\tDMI type %d, %d bytes.\n",
+			dm->handle,
+			dm->type, dm->length);
+		
+		switch(dm->type)
+		{
+			case  0:
+				printf("\tBIOS Information Block\n");
+				printf("\t\tVendor %s\n", 
+					dmi_string(dm, data[4]));
+				printf("\t\tVersion %s\n", 
+					dmi_string(dm, data[5]));
+				printf("\t\tRelease %s\n",
+					dmi_string(dm, data[8]));
+				printf("\t\tBIOS base 0x%04X0\n",
+					data[7]<<8|data[6]);
+				printf("\t\tROM size %dK\n",
+					64*data[9]);
+				printf("\t\tCapabilities:\n");
+				u=data[13]<<24|data[12]<<16|data[11]<<8|data[10];		
+				u2=data[17]<<24|data[16]<<16|data[15]<<8|data[14];
+				printf("\t\t\tFlags: 0x%08X%08X\n",
+					u2,u);
+				break;
+				
+			case 1:
+				printf("\tSystem Information Block\n");
+				printf("\t\tVendor %s\n",
+					dmi_string(dm, data[4]));
+				printf("\t\tProduct %s\n",
+					dmi_string(dm, data[5]));
+				printf("\t\tVersion %s\n",
+					dmi_string(dm, data[6]));
+				printf("\t\tSerial Number %s\n",
+					dmi_string(dm, data[7]));
+				break;
+
+			case 2:
+				printf("\tBoard Information Block\n");
+				printf("\t\tVendor %s\n",
+					dmi_string(dm, data[4]));
+				printf("\t\tProduct %s\n",
+					dmi_string(dm, data[5]));
+				printf("\t\tVersion %s\n",
+					dmi_string(dm, data[6]));
+				printf("\t\tSerial Number %s\n",
+					dmi_string(dm, data[7]));
+				break;
+
+			case 3:
+				printf("\tChassis Information Block\n");
+				printf("\t\tVendor %s\n",
+					dmi_string(dm, data[4]));
+				printf("\t\tProduct %s\n",
+					dmi_string(dm, data[5]));
+				printf("\t\tVersion %s\n",
+					dmi_string(dm, data[6]));
+				printf("\t\tSerial Number %s\n",
+					dmi_string(dm, data[7]));
+				printf("\t\tAsset Tag %s\n",
+					dmi_string(dm, data[8]));
+				break;
+			case 6:
+				printf("\tMemory Bank\n");
+				printf("\t\tSocket: %s\n", dmi_string(dm, data[4]));
+				if(data[5]!=0xFF)
+				{
+					printf("\t\tBanks: ");
+					if((data[5]&0xF0)!=0xF0)
+						printf("%d ",
+							data[5]>>4);
+					if((data[5]&0x0F)!=0x0F)
+						printf("%d",
+							data[5]&0x0F);
+					printf("\n");
+				}
+				if(data[6])
+					printf("\t\tSpeed: %dnS\n", data[6]);
+				printf("\t\tType: ");
+				dmi_decode_ram(data[7]);
+				printf("\n");
+				printf("\t\tInstalled Size: ");
+				switch(data[9]&0x7F)
+				{
+					case 0x7D:
+						printf("Unknown");break;
+					case 0x7E:
+						printf("Disabled");break;
+					case 0x7F:
+						printf("Not Installed");break;
+					default:
+						printf("%dMbyte",
+							(1<<(data[9]&0x7F)));
+				}
+				if(data[9]&0x80)
+					printf(" (Double sided)");
+				printf("\n");
+				printf("\t\tEnabled Size: ");
+				switch(data[10]&0x7F)
+				{
+					case 0x7D:
+						printf("Unknown");break;
+					case 0x7E:
+						printf("Disabled");break;
+					case 0x7F:
+						printf("Not Installed");break;
+					default:
+						printf("%dMbyte",
+							(1<<(data[10]&0x7F)));
+				}
+				if(data[10]&0x80)
+					printf(" (Double sided)");
+				printf("\n");
+				if((data[11]&4)==0)
+				{
+					if(data[11]&(1<<0))
+						printf("\t\t*** BANK HAS UNCORRECTABLE ERRORS (BIOS DISABLED)\n");
+					if(data[11]&(1<<1))
+						printf("\t\t*** BANK LOGGED CORRECTABLE ERRORS AT BOOT\n");
+				}
+				break;
+			case 7:
+			{
+				static char *types[4]={
+					"Internal ", "External ",
+					"", ""};
+				static char *modes[4]={
+					"write-through",
+					"write-back",
+					"",""};
+					
+				printf("\tCache\n");
+				printf("\t\tSocket: %s\n",
+					dmi_string(dm, data[4]));
+				u=data[6]<<8|data[5];
+				printf("\t\tL%d %s%sCache: ",
+					1+(u&7), (u&(1<<3))?"socketed ":"",
+					types[(u>>5)&3]);
+				if(u&(1<<7))
+					printf("%s\n",
+						modes[(u>>8)&3]);
+				else
+					printf("disabled\n");
+				printf("\t\tL%d Cache Size: ", 1+(u&7));
+				dmi_cache_size(data[7]|data[8]<<8);
+				printf("\t\tL%d Cache Maximum: ", 1+(u&7));
+				dmi_cache_size(data[9]|data[10]<<8);
+				printf("\t\tL%d Cache Type: ", 1+(u&7));
+				dmi_decode_cache(data[13]);
+				printf("\n");
+			}
+			break;
+
+			case 9:
+				printf("\tCard Slot\n");
+				printf("\t\tSlot: %s\n", 
+					dmi_string(dm, data[4]));
+				printf("\t\tType: %s%s%s\n",
+					dmi_bus_width(data[6]),
+					dmi_card_size(data[8]),
+					dmi_bus_name(data[5]));
+				if(data[7]==3)
+					printf("\t\tStatus: Available.\n");
+				if(data[7]==4)
+					printf("\t\tStatus: In use.\n");
+				if(data[11]&0xFE)
+					dmi_card_props(data[11]);
+				break;
+							
+			case 11:
+				printf("\tOEM Data\n");
+				for(u=0;u<data[4];u++)
+					printf("\t\t%s\n", dmi_string(dm,u));
+				break;
+			case 12:
+				printf("\tConfiguration Information\n");
+				for(u=0;u<data[4];u++)
+					printf("\t\t%s\n", dmi_string(dm,u));
+				break;
+				
+			case 15:
+				printf("\tEvent Log\n");
+				printf("\t\tLog Area: %d bytes.\n",
+					data[5]<<8|data[4]);
+				printf("\t\tLog Header At: %d.\n",
+					data[7]<<8|data[6]);
+				printf("\t\tLog Data At: %d.\n",
+					data[9]<<8|data[8]);
+				printf("\t\tLog Type: %d.\n",
+					data[10]);
+				if(data[11]&(1<<0))
+					printf("\t\tLog Valid: Yes.\n");
+				if(data[11]&(1<<1))
+					printf("\t\t**Log Is Full**.\n");
+				break;
+		}
+		data+=dm->length;
+		while(*data || data[1])
+			data++;
+		data+=2;
+		i++;
+	}
+	free(buf);
+}
+
+
+char key[8]={'R','S','D',' ','P','T','R',' '};
+
+char zot[16];
+
+int main(int argc, char *argv[])
+{
+	unsigned char buf[20];
+	int fd=open("/dev/mem", O_RDONLY);
+	long fp=0xE0000L;
+	if(fd==-1)
+	{
+		perror("/dev/mem");
+		exit(1);
+	}
+	if(lseek(fd,fp,0)==-1)
+	{
+		perror("seek");
+		exit(1);
+	}
+		
+
+	fp -= 16;
+	
+	while( fp < 0xFFFFF)
+	{
+		fp+=16;
+		if(read(fd, buf, 16)!=16)
+			perror("read");
+//		if(memcmp(buf, zot, 16)==0)
+//			printf("*");
+		if(memcmp(buf, "_SM_", 4)==0)
+			printf("SMBIOS present.\n");
+		if(memcmp(buf, "_SYSID_", 7)==0)
+			printf("SYSID present.\n");
+		if(memcmp(buf, "_DMI_", 5)==0)
+		{
+			u16 num=buf[13]<<8|buf[12];
+			u16 len=buf[7]<<8|buf[6];
+			u32 base=buf[11]<<24|buf[10]<<16|buf[9]<<8|buf[8];
+
+			printf("DMI %d.%d present.\n",
+				buf[14]>>4, buf[14]&0x0F);
+			printf("%d structures occupying %d bytes.\n",
+				buf[13]<<8|buf[12],
+				buf[7]<<8|buf[6]);
+			printf("DMI table at 0x%08X.\n",
+				buf[11]<<24|buf[10]<<16|buf[9]<<8|buf[8]);
+			dmi_table(fd, base,len, num);
+		}
+		if(memcmp(buf, "$PnP", 4)==0)
+			printf("PNP BIOS present.\n");
+		if(memcmp(buf, key, 3)==0)
+		{
+			int a;
+			unsigned char sum=0;
+			printf("RSD PTR found at 0x%luX\n", fp);
+			if(buf[15]!=0)
+			{
+				printf("Reserved check failed.\n");
+			}
+			printf("OEM ");
+			fwrite(buf+9, 6, 1, stdout);
+			printf("\n");
+			read(fd,buf+16,4);
+			lseek(fd, -4, 1);
+			for(a=0;a<20;a++)
+				sum+=buf[a];
+			if(sum!=0)
+				printf("Bad checksum.\n");
+		}
+	}
+	close(fd);
+
+	return 0;
+}
--- ipmi-ctl-2.0.orig/debian/ipmi-kcs.unpatch
+++ ipmi-ctl-2.0/debian/ipmi-kcs.unpatch
@@ -0,0 +1,32 @@
+#!/bin/sh
+#
+# Copyright 2001 Wichert Akkerman
+
+set -e
+
+thispatch=ipmi-kcs
+stamp=debian/APPLIED_i386_$thispatch
+patchdir=/usr/src/kernel-patches/i386/$thispatch
+
+if [ ! -d kernel -a -d Documentation ] ; then
+	echo "This does not seem to be a kernel source directory." >&2
+	exit 1
+fi
+
+if [ ! -f $stamp ] ; then
+	echo "The $thispatch patch is not applied"
+	exit 0
+fi
+
+patch=$(cat $stamp)
+
+if [ ! -r "$patch" ] ; then
+	echo "Can not find patch $patch which was used to patch the kernel"
+	exit 1
+fi
+
+patch -p1 -s -l -N -R < "$patch"
+rm -f $stamp
+[ -d debian ] && rmdir -p debian || true
+exit 0
+
--- ipmi-ctl-2.0.orig/debian/rules
+++ ipmi-ctl-2.0/debian/rules
@@ -0,0 +1,106 @@
+#!/usr/bin/make -f
+
+build:
+	$(MAKE)
+
+clean:
+	$(MAKE) clean
+	rm -rf debian/tmp-ctl debian/tmp-kpatch
+	rm -f debian/files debian/substvars
+
+binary: binary-arch 
+
+binary-indep:
+	@echo No binary-indendepent parts in this package
+
+binary-arch: binary-ctl binary-kpatch
+
+binary-ctl: build
+	rm -rf debian/tmp-ctl
+	rm -f debian/substvars
+
+	install -d -m 755 -o root -g root debian/tmp-ctl/usr/sbin
+	install -p -m 755 -o root -g root ipmi_ctl debian/tmp-ctl/usr/sbin/
+	install -p -m 755 -o root -g root dmidecode debian/tmp-ctl/usr/sbin/
+	strip  --strip-unneeded -R .note -R .comment \
+		debian/tmp-ctl/usr/sbin/*
+
+	install -d -m 755 -o root -g root debian/tmp-ctl/usr/share/man/man8
+	install -p -m 644 -o root -g root ipmi_ctl.8 \
+		debian/tmp-ctl/usr/share/man/man8/
+	gzip -9f debian/tmp-ctl/usr/share/man/man8/*
+
+	install -d -m 755 -o root -g root \
+		debian/tmp-ctl/usr/share/doc/ipmi-control
+	install -p -m 644 -o root -g root debian/changelog \
+		debian/tmp-ctl/usr/share/doc/ipmi-control/changelog.Debian
+	gzip -9f debian/tmp-ctl/usr/share/doc/ipmi-control/*
+	install -p -m 644 -o root -g root debian/copyright \
+		debian/tmp-ctl/usr/share/doc/ipmi-control/
+	
+	install -d -m 755 -o root -g root debian/tmp-ctl/etc/modutils
+	install -p -m 644 -o root -g root debian/modutils \
+		debian/tmp-ctl/etc/modutils/ipmi-control
+	
+	install -d -m 755 -o root -g root debian/tmp-ctl/DEBIAN
+	install -p -m 644 -o root -g root debian/ipmi-control.conffiles \
+		debian/tmp-ctl/DEBIAN/conffiles
+	set -e ; for i in postinst prerm postrm ; do \
+		install -p -m 755 -o root -g root debian/ipmi-control.$$i \
+			debian/tmp-ctl/DEBIAN/$$i ; done
+
+	dpkg-shlibdeps debian/tmp-ctl/usr/sbin/*
+	dpkg-gencontrol -isp -pipmi-control -Pdebian/tmp-ctl
+	dpkg --build debian/tmp-ctl ..
+
+binary-kpatch:
+	rm -rf debian/tmp-kpatch
+	rm -f debian/substvars
+
+	install -d -m 755 -o root -g root debian/tmp-kpatch/usr/include/linux
+	install -p -m 644 -o root -g root ipmi_ioctls.h \
+		debian/tmp-kpatch/usr/include/linux/
+
+	install -d -m 755 -o root -g root \
+		debian/tmp-kpatch/usr/src/kernel-patches/i386/apply
+	install -p -m 755 -o root -g root debian/ipmi-kcs.apply \
+		debian/tmp-kpatch/usr/src/kernel-patches/i386/apply/ipmi-kcs
+
+	install -d -m 755 -o root -g root \
+		debian/tmp-kpatch/usr/src/kernel-patches/i386/unpatch
+	install -p -m 755 -o root -g root debian/ipmi-kcs.unpatch \
+		debian/tmp-kpatch/usr/src/kernel-patches/i386/unpatch/ipmi-kcs
+
+	install -d -m 755 -o root -g root \
+		debian/tmp-kpatch/usr/src/kernel-patches/i386/ipmi-kcs
+	set -e ; for i in debian/2*.patch ; do \
+		install -p -m 644 -o root -g root $$i \
+			debian/tmp-kpatch/usr/src/kernel-patches/i386/ipmi-kcs/ ; \
+		done
+	ln -s 2.2.18_ipmi-kcs.patch \
+		debian/tmp-kpatch/usr/src/kernel-patches/i386/ipmi-kcs/2.2_ipmi-kcs.patch
+#	ln -s 2.4.0_ipmi-kcs.patch \
+#		debian/tmp-kpatch/usr/src/kernel-patches/i386/ipmi-kcs/2.4_ipmi-kcs.patch
+	
+	install -d -m 755 -o root -g root \
+		debian/tmp-kpatch/usr/share/doc/kernel-patch-ipmi-kcs
+	install -p -m 644 -o root -g root debian/changelog \
+		debian/tmp-kpatch/usr/share/doc/kernel-patch-ipmi-kcs/changelog.Debian
+	install -p -m 644 -o root -g root debian/kernel-patch-ipmi-kcs.README \
+		debian/tmp-kpatch/usr/share/doc/kernel-patch-ipmi-kcs/README.Debian
+	gzip -9f debian/tmp-kpatch/usr/share/doc/kernel-patch-ipmi-kcs/*
+	install -p -m 644 -o root -g root debian/copyright \
+		debian/tmp-kpatch/usr/share/doc/kernel-patch-ipmi-kcs/
+	
+	install -d -m 755 -o root -g root debian/tmp-kpatch/DEBIAN
+	set -e ; for i in postinst prerm ; do \
+		install -p -m 755 -o root -g root debian/kernel-patch-ipmi-kcs.$$i \
+			debian/tmp-kpatch/DEBIAN/$$i ; done
+
+	dpkg-gencontrol -isp -pkernel-patch-ipmi-kcs -Pdebian/tmp-kpatch
+	dpkg --build debian/tmp-kpatch ..
+
+.PHONY: build clean binary binary-arch binary-indep binary-kpatch
+
+# vi: nowrap
+
--- ipmi-ctl-2.0.orig/debian/2.2.18_ipmi-kcs.patch
+++ ipmi-ctl-2.0/debian/2.2.18_ipmi-kcs.patch
@@ -0,0 +1,1584 @@
+diff -urN linux-2.2.18.stock/arch/i386/kernel/traps.c linux-2.2.18/arch/i386/kernel/traps.c
+--- linux-2.2.18.stock/arch/i386/kernel/traps.c	Sun Dec 10 16:49:41 2000
++++ linux-2.2.18/arch/i386/kernel/traps.c	Fri Jan 26 18:35:08 2001
+@@ -341,9 +341,244 @@
+ 		mem_parity_error(reason, regs);
+ 	if (reason & 0x40)
+ 		io_check_error(reason, regs);
++#ifdef CONFIG_IPMI_KCS
++	if (reason & 0x20)
++		bmc_nmi_error(reason, regs);
++#endif
+ 	if (!(reason & 0xc0))
+ 		unknown_nmi_error(reason, regs);
+ }
++
++#ifdef CONFIG_IPMI_KCS
++/*
++ * The IPMI KCS NMI watchdog handler stuff
++ */
++#include <linux/config.h>
++
++#define IO 0xca2
++#define ISA_BMC_STATUS    (IO + 1)
++#define ISA_BMC_COMMAND   (IO + 1)
++#define ISA_BMC_DATA_IN       (IO + 0)
++#define ISA_BMC_DATA_OUT      (IO + 0)
++#define ISA_STATE_MASK        0xC0
++#define ISA_IDLE_STATE        0x00
++#define ISA_READ_STATE        0x40
++#define ISA_WRITE_STATE       0x80
++#define ISA_ERROR_STATE       0xC0
++#define ISA_IBF_FLAG          0x02
++#define ISA_OBF_FLAG          0x01
++#define ISA_WRITE_START        0x61
++#define ISA_WRITE_END          0X62
++#define ISA_READ               0X68
++#define MAX_ISA_LENGTH  35
++#define ISA_TIMEOUT 1000
++
++static int get_wd_counter(void);
++static int kcs_read_message(int *msglen, unsigned char *buf);
++static int wait_while_ibf(int timeout);
++static int kcs_send_message(unsigned char *buf, int length);
++static void blink(void);
++
++static void bmc_nmi_error(unsigned char reason, struct pt_regs * regs)
++{
++  unsigned char           state;
++  volatile unsigned char  status;
++  unsigned int            wd_cnt;
++
++  /* First see if we were triggered by a BMC error */
++  status = inb_p(ISA_BMC_STATUS);
++  state = (unsigned char) (status & ISA_STATE_MASK);
++
++  if (state == ISA_ERROR_STATE)
++    {
++    printk("[KCS_TRAP] Called with ISA interface in error state\n");
++    return;
++    }
++  /* Now see if the watchdog timer is in danger of tripping */
++  if ((wd_cnt = get_wd_counter())<0)
++    {
++    printk("[KCS_TRAP] Unable to verify BMC WD status.\n");
++    blink();
++    return;
++    }
++  if (wd_cnt > 10)
++    {
++    printk("[KCS_TRAP] tripped due to recoverable BMC error (wd count = %d)\n",wd_cnt);
++    return;
++    }
++  printk("[KCS_TRAP] tripped due to imminent BMC watchdog trip (wd count = %d)\n",wd_cnt);
++  blink();
++  return;
++}
++
++static void blink()
++{
++  struct cmd
++    {
++    unsigned char lun   :2;
++    unsigned char netfn :6;
++
++    unsigned char cmd;
++    } pkt;
++  memset(&pkt, 0, sizeof(pkt));
++  pkt.lun=0x00;
++  pkt.netfn=0x06;
++  pkt.cmd=0x55;
++  kcs_send_message((unsigned char *) &pkt, sizeof(pkt));
++}
++
++static int get_wd_counter()
++{
++  unsigned char reply[MAX_ISA_LENGTH];
++  int           length;
++  struct get_watchdog_response
++    {
++    unsigned char cc           __attribute__ ((packed));
++
++    unsigned char timer_use    :3;
++    unsigned char res1         :3;
++    unsigned char timer_status :1;
++    unsigned char sel_log      :1;
++
++    unsigned char timeout_act  :3;
++    unsigned char res2         :1;
++    unsigned char pre_irq_act  :3;
++    unsigned char res3         :1;
++
++    unsigned char pre_timeout __attribute__ ((packed));
++
++    unsigned char timer_use_xp  __attribute__ ((packed));
++
++    unsigned short init_count  __attribute__ ((packed));
++    unsigned short current_count __attribute__ ((packed));
++    } *g_wd_response;
++  struct cmd
++    {
++    unsigned char lun   :2;
++    unsigned char netfn :6;
++
++    unsigned char cmd;
++    } pkt;
++
++  pkt.lun = 0;
++  pkt.netfn = 6;
++  pkt.cmd = 0x25;
++  kcs_send_message((unsigned char *) &pkt, sizeof(pkt));
++  /* Packet sent. now get the response */
++  if (kcs_read_message(&length, &reply[0])<0)
++    {
++    printk("[KCS_TRAP] Read Message failed\n");
++    return(-1);
++    }
++  if (reply[2] != 0x00)
++    {
++    printk("[KCS_TRAP] GET_WATCHDOG command failed (0x%x)\n",reply[2]);
++    return(-1);
++    }
++  g_wd_response= (struct get_watchdog_response *) &reply[2];
++  return(g_wd_response->current_count);
++}
++static int kcs_read_message(int *msglen, unsigned char *buf)
++{
++  int                      i;
++  unsigned char            state;
++  volatile unsigned char  status;
++
++  for (i=0; i < MAX_ISA_LENGTH; i++)
++    {
++    status = inb_p(ISA_BMC_STATUS);
++    while(!(status & ISA_OBF_FLAG))
++      {
++      status = inb_p(ISA_BMC_STATUS);
++      state = (unsigned char) (status & ISA_STATE_MASK);
++
++      if (state == ISA_ERROR_STATE)
++        {
++        printk("[KCS_TRAP] ISA interface in ERROR state\n");
++        return (-EIO);
++        }
++      else if (state == ISA_IDLE_STATE)
++        {
++        *msglen = i;
++        return(0);
++        }
++      }
++    buf[i] = inb_p(ISA_BMC_DATA_IN);
++    if (wait_while_ibf(ISA_TIMEOUT))
++      {
++      printk("[KCS_TRAP] ISA timeout in IBF\n");
++      return(-EIO);
++      }
++    outb_p(ISA_READ, ISA_BMC_DATA_OUT);
++    }
++  printk("[KCS_TRAP] ISA Message overflow\n");
++  return (-EIO);
++}
++
++static int wait_while_ibf(int timeout)
++{
++  unsigned int master_timeout=5;
++  unsigned char status_byte;
++
++  status_byte = (inb_p(ISA_BMC_STATUS) & 0xFF);
++  while(status_byte & ISA_IBF_FLAG)
++    {
++    master_timeout--;
++    if (!master_timeout)
++      return(-1);
++    udelay(100);
++    status_byte = (inb_p(ISA_BMC_STATUS) & 0xFF);
++    }
++  return(0);
++}
++
++static int kcs_send_message(unsigned char *buf, int length)
++{
++  int           status;
++  int           i;
++  unsigned char chipstatus;
++
++  if ((status = wait_while_ibf(ISA_TIMEOUT)) <0)
++    return(-EIO);
++
++  outb_p(ISA_WRITE_START, ISA_BMC_COMMAND);
++
++  if ((status = wait_while_ibf(ISA_TIMEOUT)) <0)
++    return(-EIO);
++
++  for (i=0; i <length -1; i++)
++    {
++    chipstatus = inb_p(ISA_BMC_STATUS);
++
++    if (chipstatus & ISA_OBF_FLAG)
++      inb_p(ISA_BMC_DATA_IN);
++
++    if ((chipstatus & ISA_STATE_MASK) != ISA_WRITE_STATE)
++      {
++      printk("[KCS_TRAP] ISA write state fault (0x%x)\n",chipstatus);
++      return(-EIO);
++      }
++    outb_p(buf[i], ISA_BMC_DATA_OUT);
++    if ((status = wait_while_ibf(ISA_TIMEOUT)) <0)
++      return(-EIO);
++    }
++  outb_p(ISA_WRITE_END, ISA_BMC_COMMAND);
++  if ((status = wait_while_ibf(ISA_TIMEOUT)) <0)
++    return(-EIO);
++  outb_p(buf[i], ISA_BMC_DATA_OUT);
++  if ((status = wait_while_ibf(ISA_TIMEOUT)) <0)
++    return(-EIO);
++
++  chipstatus = inb_p(ISA_BMC_STATUS);
++  if ((chipstatus & ISA_STATE_MASK) !=ISA_READ_STATE)
++    {
++    printk("[KCS_TRAP] ISA read state fault (0x%x)\n",chipstatus);
++    return (-EIO);
++    }
++  return(0);
++}
++/* END of KCS watchdog trap handler */
++#endif
+ 
+ /*
+  * Careful - we must not do a lock-kernel until we have checked that the
+diff -urN linux-2.2.18.stock/drivers/char/Config.in linux-2.2.18/drivers/char/Config.in
+--- linux-2.2.18.stock/drivers/char/Config.in	Sun Dec 10 16:49:41 2000
++++ linux-2.2.18/drivers/char/Config.in	Fri Jan 26 18:30:54 2001
+@@ -94,6 +94,8 @@
+   fi
+ fi
+ 
++tristate 'IPMI KCS Interface' CONFIG_IPMI_KCS
++
+ bool 'Watchdog Timer Support'	CONFIG_WATCHDOG
+ if [ "$CONFIG_WATCHDOG" != "n" ]; then
+   mainmenu_option next_comment
+diff -urN linux-2.2.18.stock/drivers/char/Makefile linux-2.2.18/drivers/char/Makefile
+--- linux-2.2.18.stock/drivers/char/Makefile	Sun Dec 10 16:49:41 2000
++++ linux-2.2.18/drivers/char/Makefile	Fri Jan 26 18:30:00 2001
+@@ -311,6 +311,14 @@
+   endif
+ endif
+ 
++ifeq ($(CONFIG_IPMI_KCS),y)
++O_OBJS += ipmi_kcs.o
++else
++  ifeq ($(CONFIG_IPMI_KCS),m)
++  M_OBJS +=ipmi_kcs.o
++  endif
++endif
++
+ ifeq ($(CONFIG_AMIGAMOUSE),y)
+ O_OBJS += amigamouse.o
+ else
+diff -urN linux-2.2.18.stock/drivers/char/ipmi_kcs.c linux-2.2.18/drivers/char/ipmi_kcs.c
+--- linux-2.2.18.stock/drivers/char/ipmi_kcs.c	Wed Dec 31 16:00:00 1969
++++ linux-2.2.18/drivers/char/ipmi_kcs.c	Fri Jan 26 18:27:07 2001
+@@ -0,0 +1,992 @@
++/*
++ *  Intelligent Platform Management Interface driver for Linux 2.2.x
++ *
++ *  (c) Copyright 2000 San Mehat <nettwerk@valinux.com>, All Rights Reserved.
++ *        http://www.valinux.com
++ *
++ *  This program is free software; you can redistribute it and/or
++ *  modify it under the terms of the GNU General Public License
++ *  as published by the Free Software Foundation; either version
++ *  2 of the License, or (at your option) any later version.
++ *  
++ *  Neither San Mehat nor VA Linux Systems admit liability nor provide 
++ *  warranty for any of this software. This material is provided 
++ *  "AS-IS" and at no charge.  
++ *
++ *  (c) Copyright 1999    San Mehat <nettwerk@valinux.com>
++ *
++ *  Release 0.04.   - Initial Release
++ *  
++ *  Release 0.05.   - Fixed ring buffer bugs... better buffer handling
++ *
++ *  Release 0.06.   - Changed polling freq to 1/10 sec
++ *
++ *  Release 0.07.   - Integrated watchdog commands into IOCTL's and added
++ *                    support for blinking front panel LED
++ *
++ *  Release 0.08.   - Sensor read commands added as ioctl
++ *
++ *  Release 0.09.   - Changed polling freq back to 1 second
++ *                  - Fixed possible bug where a chip status variable was
++ *                    not declared volatile.
++ *                  - Fixed buffer memory leak
++ *                  - Fixed ioctl return value problem
++ *                  - Changed architecture so that applications calling
++ *                    driver ioctl()'s are put to sleep after request
++ *                    is sent. The reply is handled by the normal
++ *                    driver polling timer queue and ring buffer
++ *
++ *  Release 0.10.   - Modified kcs_write routine so once a write is complete
++ *                    if the interface isn't in a 'READ STATE' it's okay.
++ *
++ *  Release 0.12.   - Added Intel Nightshade MB fixups since NS boards don't
++ *                    support pre-timeout NMI support
++ *                  - FRU download support added
++ *                  - /proc/ipmi created with fru data and driver status
++ *  Release 0.13.   - Added ioctl for setting asset tag
++ *                  - Fixed bug in /proc
++ *                  - Added asset tag max length field
++ *  Release 1.00    - Added intelligent proc reading so that asset tag is
++ *                    refreshed whenever /proc/ipmi is read
++ *                  - Code cleanup
++ *                  - When asset tag is set with data whoes size is < maximum,
++ *                    pad the rest out with NULLs
++ *  Release 1.10    - Fixed SMP bug which was causing command failures when
++ *                    /proc/ipmi was being read while a command was being 
++ *                    executed (added semaphore)
++ *                  - Fixed /proc/ipmi so commands only get issued once
++ *  Release 1.20    - Removed a bunch of useless warning msgs
++ *  Release 1.30    - Added more stringent error checking when ISA state
++ *                    enters ERROR_STATE
++ *                  - Added better unexpected OBF handling on transactions
++ *                  - Explicitly set power sensor state to NO BLINKY on 
++ *                    startup
++ *  Release 2.0     - Re-wrote kcs state machine
++ *                  - Removed high level functions from driver
++ *                  - removed driver read() and write() capabilities
++ *                  - /proc/ipmi renamed to /proc/ipmi_kcs
++ *                  - /proc/ipmi_kcs now contains only BMC info
++ *                    
++ */
++
++#include <linux/config.h>
++#include <linux/module.h>
++#include <linux/version.h>
++#include <linux/types.h>
++#include <linux/errno.h>
++#include <linux/kernel.h>
++#include <linux/sched.h>
++#include <linux/miscdevice.h>
++#include "ipmi_kcs.h"
++#include <linux/malloc.h>
++#include <linux/ioport.h>
++#include <linux/fcntl.h>
++#include <asm/io.h>
++#include <asm/uaccess.h>
++#include <asm/system.h>
++#include <linux/reboot.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++#include <linux/timer.h>
++#include <linux/ipmi_ioctls.h>
++#include <linux/pci.h>
++
++#ifdef CONFIG_PROC_FS
++#include <linux/proc_fs.h>
++#endif
++
++/* function prototypes */
++
++int ipmi_kcs_init(void);
++
++static int kcs_open(struct inode	*inode,
++										struct file		*file);
++static int kcs_release(	struct inode	*inode,
++												struct file		*file);
++static ssize_t kcs_read(struct file *file,
++												char				*buf,
++												size_t			count,
++												loff_t			*ptr);
++static ssize_t kcs_write(	struct file	*file,
++													const char	*buf,
++													size_t			count,
++													loff_t			*ppos);
++static long long kcs_llseek(struct file	*file,
++														long long		offset,
++														int					origin);
++static int kcs_ioctl(	struct inode	*inode,
++											struct file		*file,
++											unsigned int	cmd,
++											unsigned long	arg);
++
++static unsigned char get_kcs_state(void);
++static unsigned char read_kcs_data(void);
++static void write_kcs_data(unsigned char data);
++static void write_kcs_cmd(unsigned char	cmd);
++static int is_obf_set(void);
++static int clear_obf(void);
++static int wait_while_ibf(void);
++static int get_deviceid(void);
++static int kcs_do_xfer(	BMC_REQUEST		*request,
++												int						request_len,
++												BMC_RESPONSE	*response,
++												int						*response_len);
++static int old_kcs_do_xfer(	BMC_REQUEST		*request,
++														int						request_len,
++														BMC_RESPONSE	*response,
++														int						*response_len);
++static int new_kcs_do_xfer(	BMC_REQUEST		*request,
++														int						request_len,
++														BMC_RESPONSE	*response,
++														int						*response_len);
++
++#ifdef CONFIG_PROC_FS
++static int  ipmi_get_info(char *, char **, off_t, int, int);
++#endif
++
++/* static globals */
++static int					kcs_refcnt=0;
++static int					driver_major = 2;
++static int					driver_minor = 0;
++static int					kcs_machine  = 0;
++
++static struct
++	{
++	unsigned int	tx_good;
++	unsigned int	tx_bad;
++	} kcs_stat;
++
++static DEVICE_ID_RESPONSE	dev_id;
++static struct semaphore		kcs_sem = MUTEX;
++
++#ifdef CONFIG_PROC_FS
++static struct proc_dir_entry ipmi_proc_entry = {
++  0,
++  8,
++  "ipmi_kcs",
++  S_IFREG | S_IRUGO,
++  1,
++  0,
++  0,
++  0,
++  0,
++  ipmi_get_info
++  };
++#endif
++
++static struct file_operations kcs_fops = {
++  kcs_llseek,
++  kcs_read,
++  kcs_write,
++  NULL,    /* No Readdir */
++  NULL,    /* No Select */
++  kcs_ioctl,
++  NULL,    /* No mmap */
++  kcs_open,
++  NULL,    /* flush */
++  kcs_release
++};
++
++static struct miscdevice kcs_miscdev=
++{
++  IPMI_KCS_MINOR,
++  "ipmi_kcs",
++  &kcs_fops
++};
++
++static struct ipmi_driver_info drv_inf;
++
++/***************/
++
++static long long kcs_llseek(struct file *file, long long offset, int origin)
++{
++  return -ESPIPE;
++}
++
++static ssize_t kcs_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
++{
++	return (-ENOSYS);
++}
++
++static ssize_t kcs_read(struct file *file, char *buf, size_t count, loff_t *ptr)
++{
++	return (-ENOSYS);
++}
++
++static int kcs_ioctl(struct inode  *inode,
++                     struct file   *file,
++                     unsigned int  cmd,
++                     unsigned long arg)
++{
++  switch(cmd)
++    {
++		case IOCTL_IPMI_XFER:
++			{
++			IPMI_XFER	user_buffer;
++			int				rc;
++			int				response_len = sizeof(user_buffer.response);
++
++			if (!arg)
++				return(-EFAULT);
++			if (copy_from_user((void *) &user_buffer, (void *) arg, sizeof(IPMI_XFER)))
++				return(-EFAULT);
++			if ((user_buffer.request_len < 2) || (user_buffer.response_len < 3))
++				return(-EINVAL);
++			
++			rc = kcs_do_xfer( (BMC_REQUEST *) &user_buffer.request,
++												user_buffer.request_len,
++												(BMC_RESPONSE *) &user_buffer.response,
++												&response_len);
++			user_buffer.response_len = response_len;
++			copy_to_user((void *) arg, (void *) &user_buffer, sizeof(IPMI_XFER));
++			return(rc);
++			}
++		case IOCTL_DRIVER_INFO:
++			{
++			struct ipmi_driver_info	user_buffer;
++
++			if (!arg)
++				return(-EFAULT);
++			if (copy_from_user((void *) &user_buffer, (void *) arg, sizeof(user_buffer)))
++				return(-EFAULT);
++			copy_to_user((void *) arg, (void *) &drv_inf, sizeof(drv_inf));
++			return(0);
++			}
++		default:
++    	return -EINVAL;
++    }
++  return (0);
++}
++
++static int get_deviceid()
++{
++	unsigned char	request_buffer[MAX_BUFFER_SIZE];
++	unsigned char	response_buffer[MAX_BUFFER_SIZE];
++	BMC_REQUEST		*bmc_req;
++	BMC_RESPONSE	*bmc_resp;
++	int						rc, response_len;
++
++	memset(&dev_id, 0, sizeof(DEVICE_ID_RESPONSE));
++	memset(request_buffer, 0, sizeof(request_buffer));
++	memset(response_buffer, 0, sizeof(response_buffer));
++	bmc_req = (BMC_REQUEST *) request_buffer;
++	bmc_resp= (BMC_RESPONSE *) response_buffer;
++	response_len = sizeof(response_buffer);
++
++	bmc_req->lun = 0;
++	bmc_req->netfn = APP_REQUEST;
++	bmc_req->cmd = 0x01; /* GET_DEVICE_ID */
++
++	rc = old_kcs_do_xfer(	bmc_req,
++												2,
++												bmc_resp,
++												&response_len);
++	if (bmc_resp->cc != 0x00)
++		{
++		printk("[IPMI_KCS] get_deviceid() failed (0x%.2x)\n",bmc_resp->cc);
++		return(-EIO);
++		}
++	memcpy(&dev_id, bmc_resp->data, sizeof(DEVICE_ID_RESPONSE));
++  return(0);
++}
++
++static int kcs_open(struct inode *inode, struct file *file)
++{
++  switch(MINOR(inode->i_rdev))
++    {
++    case IPMI_KCS_MINOR:
++      {
++      MOD_INC_USE_COUNT;
++      kcs_refcnt++;
++      return 0;
++      }
++    default:
++      return -ENODEV;
++    }
++}
++
++static int kcs_release(struct inode *inode, struct file *file)
++{
++  if(MINOR(inode->i_rdev)==IPMI_KCS_MINOR)
++		{
++    kcs_refcnt--;
++		}
++  MOD_DEC_USE_COUNT;
++  return 0;
++}
++
++#ifdef MODULE
++#define kcs_init init_module
++
++__initfunc(int kcs_init(void))
++{
++  return(ipmi_kcs_init());
++}
++
++void cleanup_module(void)
++{
++  printk("[IPMI_KCS] Driver shutting down.\n");
++#ifdef CONFIG_PROC_FS
++  proc_unregister(&proc_root, ipmi_proc_entry.low_ino);
++#endif
++  misc_deregister(&kcs_miscdev);
++  release_region(KCS_BASE,16);
++}
++#endif
++
++int ipmi_kcs_init()
++{
++  printk("IPMI KCS driver (San Mehat nettwerk@valinux.com) v%d.%d at io 0x%x\n",
++          driver_major,
++          driver_minor,
++          KCS_BASE);
++  request_region(KCS_BASE, 16, "ipmi_kcs");
++  if ((inb_p(KCS_STATUS_REG) == 0xFF) &&
++      (inb_p(KCS_DATAIN_REG) == 0xFF))
++    {
++    printk("--KCS ISA window not present. Driver exiting\n");
++    release_region(KCS_BASE,16);
++    return(-ENXIO);
++    }
++	
++	kcs_stat.tx_good = 0;
++	kcs_stat.tx_bad = 0;
++	memset(&drv_inf, 0, sizeof(drv_inf));
++	strcpy(drv_inf.driver_name, "ipmi_kcs");
++	drv_inf.major_ver = driver_major;
++	drv_inf.minor_ver = driver_minor;
++
++  misc_register(&kcs_miscdev);
++  get_deviceid();
++  printk("--BMC version %x.%x, IPMI version %d.%d\n",
++          dev_id.major_firmware_revision,
++          dev_id.minor_firmware_revision,
++          dev_id.ipmi_version_major,
++          dev_id.ipmi_version_minor);
++	if ((dev_id.ipmi_version_major == 0) &&
++			(dev_id.ipmi_version_minor == 9))
++		{
++		printk("--Using legacy KCS state machine\n");
++		kcs_machine = KCS_LEGACY;
++		drv_inf.flags |= KCS_FLAG_LEGACY;
++		}
++	else
++		{
++		printk("--Using new KCS state machine\n");
++		kcs_machine = KCS_NEW;
++		}
++	if (!pci_present())
++		{
++		printk("--PCIBIOS not present. Unable to determine chipset vendor\n");
++		drv_inf.flags |= KCS_FLAG_BLINKY;
++		}
++	else
++		{
++		int							pci_index = 0;
++		unsigned char		pci_bus, pci_device_fn;
++		unsigned short	vendor, device;
++
++		for (;pci_index < 0xff; pci_index++)
++			{
++			if (pcibios_find_class(PCI_CLASS_BRIDGE_HOST << 8, 
++														 pci_index,
++														 &pci_bus,
++														 &pci_device_fn) != PCIBIOS_SUCCESSFUL)
++				{
++				break;
++				}
++			pcibios_read_config_word(pci_bus, pci_device_fn,
++															 PCI_VENDOR_ID, &vendor);
++			pcibios_read_config_word(pci_bus, pci_device_fn,
++															 PCI_DEVICE_ID, &device);
++			drv_inf.mb_chipset_vendor = vendor;
++			drv_inf.mb_chipset_device = device;
++			printk("--Motherboard Chipset vendor 0x%.4x, device 0x%.4x\n",
++						vendor, device);
++			if ((vendor == 0x8086) &&
++					(device == 0x71a0))
++				{
++				drv_inf.flags |= KCS_FLAG_BLINKY;
++				}
++			}
++		}
++	if (drv_inf.flags & KCS_FLAG_BLINKY)
++		{
++		printk("--Intel Lancewood features enabled\n");
++		}
++	else
++		printk("--No vendor specific features enabled\n");
++#ifdef CONFIG_PROC_FS
++  proc_register(&proc_root, &ipmi_proc_entry);
++#endif
++  return(0);
++}
++
++static int kcs_do_xfer(	BMC_REQUEST		*request,
++												int						request_len,
++												BMC_RESPONSE	*response,
++												int						*response_len)
++{
++	int	rc = 0;
++
++	down(&kcs_sem);
++	switch(kcs_machine)
++		{
++		case KCS_LEGACY:
++			{
++			rc = old_kcs_do_xfer(request, request_len, response, response_len);
++			break;
++			}
++		case KCS_NEW:
++			{
++			rc = new_kcs_do_xfer(request, request_len, response, response_len);
++			break;
++			}
++		default:
++			{
++			printk("[IPMI_KCS] Undefined or bad KCS state machine selected (%d)\n",
++							kcs_machine);
++			get_deviceid();
++			if ((dev_id.ipmi_version_major == 0) &&
++				(dev_id.ipmi_version_minor == 9))
++				{
++				printk("Recalibrated to use legacy KCS state machine\n");
++				kcs_machine = KCS_LEGACY;
++				}
++			else
++				{
++				printk("Recalibrated to use new KCS state machine\n");
++				kcs_machine = KCS_NEW;
++				}
++			rc = -EAGAIN;
++			break;
++			}
++		}
++	if (rc == 0)
++		kcs_stat.tx_good ++;
++	else
++		kcs_stat.tx_bad ++;
++	up(&kcs_sem);
++	return(rc);
++}
++
++static int new_kcs_do_xfer(	BMC_REQUEST		*request,
++														int						request_len,
++														BMC_RESPONSE	*response,
++														int						*response_len)
++{
++	unsigned char	*xmit_buffer, *recv_buffer;
++	int						i = 0, rc = 0, state = SEND_INIT, bad = 0;
++
++	xmit_buffer = (unsigned char *) request;
++	recv_buffer = (unsigned char *) response;
++
++	while(1)
++		{
++		if (state == END)
++			break;
++		else if (bad > 2)
++			{
++			printk("[IPMI_KCS] Maximum retries exceeded. Aborting transfer\n");
++			rc = -EIO;
++			break;
++			}
++		switch (state)
++			{
++			case SEND_INIT:
++				{
++				i = 0;
++				state = SEND_START;
++				wait_while_ibf();
++				if (clear_obf() != 0)
++					{
++					state = ERROR;
++					break;
++					}
++				}
++			case SEND_START:
++				{
++				state = SEND_NEXT;
++				write_kcs_cmd(WRITE_START);
++				wait_while_ibf();
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				}
++			case SEND_NEXT:
++				{
++				if (i == (request_len -1))
++					{
++					state = SEND_END;
++					break;
++					}
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				write_kcs_data(xmit_buffer[i++]);
++				wait_while_ibf();
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				if (clear_obf() != 0)
++					{
++					state = ERROR;
++					break;
++					}
++				break;
++				}
++			case SEND_END:
++				{
++				write_kcs_cmd(WRITE_END);
++				wait_while_ibf();
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				if (clear_obf()!= 0)
++					{
++					state = ERROR;
++					break;
++					}
++				write_kcs_data(xmit_buffer[i++]);
++				wait_while_ibf();
++				state = RECV_START;
++				}
++			case RECV_START:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_WRITE_STATE:
++					case KCS_IDLE_STATE:
++						{
++						mdelay(BMC_RESPONSE_DELAY);
++						break;
++						}
++					case KCS_READ_STATE:
++						{
++						i = 0;
++						memset(recv_buffer, 0, *response_len);
++						state = RECV_INIT;
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_INIT:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++					case KCS_WRITE_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_IDLE_STATE:
++						{
++						state = RECV_END;
++						break;
++						}
++					case KCS_READ_STATE:
++						{
++						if (is_obf_set())
++							state = RECV_NEXT;
++						else
++							mdelay(1);
++						break;
++						}
++					default:
++						{
++						mdelay(1);
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_NEXT:
++				{
++				if (i >= *response_len)
++					{
++					rc = -EOVERFLOW;
++					state = ERROR;
++					break;
++					}
++				recv_buffer[i++] = read_kcs_data();
++				write_kcs_data(KCS_READ);
++				wait_while_ibf();
++				state = RECV_INIT2;
++				break;
++				}
++			case RECV_INIT2:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++					case KCS_WRITE_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_IDLE_STATE:
++						{
++						if (wait_until_obf() == 0)
++							{
++							clear_obf();
++							state = RECV_END;
++							break;
++							}
++						else
++							{
++							state = ERROR;
++							break;
++							}
++						}
++					case KCS_READ_STATE:
++						{
++						if (wait_until_obf() == 0)
++							state = RECV_NEXT;
++						else
++							state = ERROR;
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_END:
++				{
++				if ((i < MIN_BMC_RESPONSE_SIZE) ||
++						(response->netfn != (request->netfn | 0x01)) ||
++						(response->cmd   != request->cmd))
++					{
++					mdelay(BMC_RETRY_DELAY);
++					bad++;
++					state = SEND_INIT;
++					printk("[IPMI_KCS] Request/Response CMD/NETFN mismatch error\n");
++		
++					printk("           RQcmd/RQnetfn=0x%x/0x%x,RScmd/RSnetfn=0x%x/0x%x\n",
++									request->cmd, request->netfn, response->cmd, response->netfn);
++					break;
++					}
++		
++				*response_len = i;
++				rc = 0;
++				state = END;
++				break;
++				}
++			case ERROR:
++			default:
++				{
++				printk("[IPMI_KCS] BMC in bad state. Retrying transfer\n");
++				mdelay(BMC_RETRY_DELAY);
++				bad++;
++				state = SEND_INIT;
++				break;
++				}
++			}
++		}
++	return(rc);
++}
++
++static int old_kcs_do_xfer(	BMC_REQUEST		*request,
++														int						request_len,
++														BMC_RESPONSE	*response,
++														int						*response_len)
++{
++	unsigned char	*xmit_buffer, *recv_buffer;
++	int						i = 0, rc = 0, state = SEND_INIT, bad = 0;
++
++	xmit_buffer = (unsigned char *) request;
++	recv_buffer = (unsigned char *) response;
++
++	while(1)
++		{
++		if (state == END)
++			break;
++		else if (bad > 2)
++			{
++			printk("[IPMI_KCS] Maximum retries exceeded. Aborting transfer\n");
++			rc = -EIO;
++			break;
++			}
++		switch (state)
++			{
++			case SEND_INIT:
++				{
++				i = 0;
++				state = SEND_START;
++				wait_while_ibf();
++				}
++			case SEND_START:
++				{
++				state = SEND_NEXT;
++				write_kcs_cmd(WRITE_START);
++				wait_while_ibf();
++				}
++			case SEND_NEXT:
++				{
++				if (i == (request_len -1))
++					{
++					state = SEND_END;
++					break;
++					}
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				write_kcs_data(xmit_buffer[i++]);
++				wait_while_ibf();
++				break;
++				}
++			case SEND_END:
++				{
++				wait_while_ibf();
++				write_kcs_cmd(WRITE_END);
++				wait_while_ibf();
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				write_kcs_data(xmit_buffer[i++]);
++				wait_while_ibf();
++				state = RECV_START;
++				}
++			case RECV_START:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_WRITE_STATE:
++					case KCS_IDLE_STATE:
++						{
++						mdelay(BMC_RESPONSE_DELAY);
++						break;
++						}
++					case KCS_READ_STATE:
++						{
++						i = 0;
++						memset(recv_buffer, 0, *response_len);
++						state = RECV_INIT;
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_INIT:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++					case KCS_WRITE_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_IDLE_STATE:
++						{
++						state = RECV_END;
++						break;
++						}
++					case KCS_READ_STATE:
++						{
++						if (is_obf_set())
++							state = RECV_NEXT;
++						else
++							mdelay(1);
++						break;
++						}
++					default:
++						{
++						mdelay(1);
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_NEXT:
++				{
++				if (i >= *response_len)
++					{
++					rc = -EOVERFLOW;
++					state = ERROR;
++					break;
++					}
++				recv_buffer[i++] = read_kcs_data();
++				wait_while_ibf();
++				write_kcs_data(KCS_READ);
++				state = RECV_INIT2;
++				break;
++				}
++			case RECV_INIT2:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++					case KCS_WRITE_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_IDLE_STATE:
++						{
++						state = RECV_END;
++						break;
++						}
++					case KCS_READ_STATE:
++						{
++						if (is_obf_set())
++							state = RECV_NEXT;
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_END:
++				{
++				if ((i < MIN_BMC_RESPONSE_SIZE) ||
++						(response->netfn != (request->netfn | 0x01)) ||
++						(response->cmd   != request->cmd))
++					{
++					mdelay(BMC_RETRY_DELAY);
++					bad++;
++					state = SEND_INIT;
++					printk("[IPMI_KCS] Request/Response CMD/NETFN mismatch error\n");
++		
++					printk("           RQcmd/RQnetfn=0x%x/0x%x,RScmd/RSnetfn=0x%x/0x%x\n",
++									request->cmd, request->netfn, response->cmd, response->netfn);
++					break;
++					}
++		
++				*response_len = i;
++				rc = 0;
++				state = END;
++				break;
++				}
++			case ERROR:
++			default:
++				{
++				printk("[IPMI_KCS] BMC in bad state. Retrying transfer\n");
++				mdelay(BMC_RETRY_DELAY);
++				bad++;
++				state = SEND_INIT;
++				break;
++				}
++			}
++		}
++	return(rc);
++}
++	
++#ifdef CONFIG_PROC_FS
++int ipmi_get_info(char *buf, char **start, off_t fpos, int length, int dummy)
++{
++  char    *p;
++
++ 	if (get_deviceid()!= 0)
++   	{
++   	printk("[IPMI_KCS] Unable to get device ID\n");
++   	memset(&dev_id, 0, sizeof(dev_id));
++   	}
++
++  p = buf;
++  p+= sprintf(p, "Driver Version\t: %d.%d\n",
++              driver_major,driver_minor);
++  p+=sprintf(p, "BMC Version\t: %x.%x\n",
++            dev_id.major_firmware_revision,
++            dev_id.minor_firmware_revision);
++  p+=sprintf(p, "IPMI Version\t: %d.%d\n",
++            dev_id.ipmi_version_major,
++            dev_id.ipmi_version_minor);
++	p+=sprintf(p, "\nTotal Good Transactions\t: %d\n",kcs_stat.tx_good);
++	p+=sprintf(p, "Total Bad Transactions\t: %d\n",kcs_stat.tx_bad);
++
++  return p - buf;
++}
++#endif
++
++/*
++ * kcs chip mashing stuff
++ */
++static int wait_while_ibf()
++{
++  unsigned char status_byte;
++
++ 	status_byte = inb_p(KCS_STATUS_REG);
++	if ((status_byte & KCS_IBF)== 0)
++		return(0);
++	mdelay(KCS_READY_DELAY);
++ 	status_byte = inb_p(KCS_STATUS_REG);
++	if (status_byte & KCS_IBF)
++		return(-1);
++	return(0);
++}
++
++static int wait_until_obf()
++{
++	int	retries = 0;
++
++	while(retries < 2)
++		{
++		if (is_obf_set())
++			return(0);
++		mdelay(KCS_READY_DELAY);
++		retries++;
++		}
++  return(-ETIMEDOUT);
++}
++
++static unsigned char get_kcs_state()
++{
++	unsigned char cs;
++
++	cs = inb_p(KCS_STATUS_REG);
++	return(cs & KCS_STATE_MASK);
++}
++
++static unsigned char read_kcs_data()
++{
++	unsigned char	data;
++
++	data = inb_p(KCS_DATAOUT_REG);
++	return(data);
++}
++
++static void write_kcs_data(unsigned char	data)
++{
++  outb_p(data, KCS_DATAIN_REG);
++}
++
++static void write_kcs_cmd(unsigned char	cmd)
++{
++  outb_p(cmd, KCS_COMMAND_REG);
++}
++
++static int is_obf_set()
++{
++	unsigned char cs;
++
++	cs = inb_p(KCS_STATUS_REG);
++	return((cs & KCS_OBF) == KCS_OBF);
++}
++
++static int clear_obf()
++{
++	read_kcs_data();
++	return(0);
++}
+diff -urN linux-2.2.18.stock/drivers/char/ipmi_kcs.h linux-2.2.18/drivers/char/ipmi_kcs.h
+--- linux-2.2.18.stock/drivers/char/ipmi_kcs.h	Wed Dec 31 16:00:00 1969
++++ linux-2.2.18/drivers/char/ipmi_kcs.h	Fri Jan 26 18:27:07 2001
+@@ -0,0 +1,123 @@
++/*
++ *  Intelligent Platform Management Interface driver for Linux 2.x
++ *
++ *  (c) Copyright 1999  San Mehat & VA Linux Systems
++ *        1382 Bordeaux Dr.
++ *        Sunnyvale, California
++ *        94089
++ *
++ *  http://www.valinux.com
++ *
++ *  This driver is provided under the GNU public license, incorporated
++ *  herein by reference. The driver is provided without warranty or
++ *  support.
++ *
++ *
++ */
++
++#include <linux/config.h>
++
++#define KCS_LEGACY					1
++#define KCS_NEW							2
++
++#define KCS_READY_DELAY			5
++#define BMC_RESPONSE_DELAY	5
++#define BMC_RETRY_DELAY			60
++
++#define KCS_BASE 					0xca2
++#define KCS_STATUS_REG    (KCS_BASE + 1)
++#define KCS_COMMAND_REG   (KCS_BASE + 1)
++#define KCS_DATAIN_REG    (KCS_BASE + 0)
++#define KCS_DATAOUT_REG   (KCS_BASE + 0)
++
++/* State bits based on S1 & S0 below */
++#define KCS_STATE_MASK        0xC0
++#define KCS_IDLE_STATE        0x00
++#define KCS_READ_STATE        0x40
++#define KCS_WRITE_STATE       0x80
++#define KCS_ERROR_STATE       0xC0
++
++#define KCS_IBF								0x02
++#define KCS_OBF								0x01
++#define KCS_SMS_ATN						0x04
++
++#define SEND_INIT				1
++#define SEND_START			2
++#define SEND_NEXT				3
++#define SEND_END				4
++#define RECV_START			5
++#define RECV_INIT				6
++#define RECV_NEXT				7
++#define RECV_INIT2			8
++#define RECV_END				9
++#define END							10
++#define ERROR						0
++
++/* SMS Transfer Stream Control Codes */
++#define GET_STATUS_ABORT   0x60
++#define WRITE_START	0x61
++#define WRITE_END		0x62
++#define KCS_READ		0x68
++
++#define MAX_INVALID_RESPONSE_COUNT    2
++#define MIN_BMC_RESPONSE_SIZE         3
++#define MAX_IMB_PACKET_SIZE           33
++#define MAX_BMC_RESPONSE_SIZE (MIN_BMC_RESPONSE_SIZE + MAX_IMB_PACKET_SIZE)
++#define MAX_XFER_LENGTH               (MAX_IMB_PACKET_SIZE * 2)                 
++
++#define MAX_BUFFER_SIZE								64
++
++typedef struct bmc_response
++	{
++  unsigned char lun               :2;
++  unsigned char netfn             :6;
++
++  unsigned char cmd;
++	unsigned char	cc;
++	unsigned char	data[1];
++	}BMC_RESPONSE;
++
++typedef struct bmc_request
++	{
++  unsigned char lun               :2;
++  unsigned char netfn             :6;
++
++  unsigned char cmd;
++	unsigned char	data[1];
++	}BMC_REQUEST;
++
++/* GET_DEVICE_ID RESPONSE */
++typedef struct device_id_response
++  {
++  unsigned char device_id;
++  
++  unsigned char device_revision         :4;
++  unsigned char reserved                :3;
++  unsigned char provides_sdr            :1;
++  
++  unsigned char major_firmware_revision :7;
++  #define NORMAL_OPERATION  0
++  #define DEVICE_BUSY       1
++  unsigned char device_available        :1;
++  
++  unsigned char minor_firmware_revision;
++  
++  unsigned char ipmi_version_major      :4;
++  unsigned char ipmi_version_minor      :4;
++  
++  unsigned char supports_sensor_device  :1;
++  unsigned char supports_sdr_device     :1;
++  unsigned char supports_sel_device     :1;
++  unsigned char supports_fru_device     :1;
++  unsigned char supports_ipmb_receiver  :1;
++  unsigned char supports_ipmb_generator :1;
++  unsigned char supports_bridge         :1;
++  unsigned char supports_chassis_device :1;
++  
++  unsigned char manufacturer_id1;
++  unsigned char manufacturer_id2;
++  unsigned char manufacturer_id3;
++  
++  unsigned short product_id;
++  } DEVICE_ID_RESPONSE;
++
+diff -urN linux-2.2.18.stock/drivers/char/misc.c linux-2.2.18/drivers/char/misc.c
+--- linux-2.2.18.stock/drivers/char/misc.c	Sun Dec 10 16:49:42 2000
++++ linux-2.2.18/drivers/char/misc.c	Fri Jan 26 18:36:18 2001
+@@ -281,6 +281,10 @@
+ #ifdef CONFIG_TOSHIBA
+ 	tosh_init();
+ #endif
++
++#ifdef CONFIG_IPMI_KCS
++	ipmi_kcs_init();
++#endif
+ 	if (register_chrdev(MISC_MAJOR,"misc",&misc_fops)) {
+ 		printk("unable to get major %d for misc devices\n",
+ 		       MISC_MAJOR);
+diff -urN linux-2.2.18.stock/include/linux/ipmi_ioctls.h linux-2.2.18/include/linux/ipmi_ioctls.h
+--- linux-2.2.18.stock/include/linux/ipmi_ioctls.h	Wed Dec 31 16:00:00 1969
++++ linux-2.2.18/include/linux/ipmi_ioctls.h	Fri Jan 26 18:27:15 2001
+@@ -0,0 +1,152 @@
++/*
++ *  Intelligent Platform Management Interface driver for Linux 2.x
++ *
++ *  (c) Copyright 1999  San Mehat & VA Linux Systems
++ *        1382 Bordeaux Dr.
++ *        Sunnyvale, California
++ *        94089
++ *
++ *  http://www.valinux.com
++ *
++ *  This driver is provided under the GNU public license, incorporated
++ *  herein by reference. The driver is provided without warranty or
++ *  support.
++ *
++ *  IOCTL definitions for IPMI drivers
++ */
++
++/*
++ * Note: The following macros should be used on the IPMI_XFER structure.
++ *       DO NOT try to muck with this structure directly.. use the macros
++ *       to ensure future compatibility:
++ *
++ *  INIT_XFER(IPMI_XFER *);  
++ *    -- Zero out a IPMI_XFER structure and initialize it for use
++ *
++ *  SET_REQUEST_LUN(IPMI_XFER *, unsigned char lun);
++ *    -- Set the request packet logical unit
++ *
++ *  SET_REQUEST_NETFN(IPMI_XFER *, unsigned char netfn);
++ *    -- Set the request packet network function code
++ *
++ *  SET_REQUEST_CMD(IPMI_XFER *, unsigned char cmd);
++ *    -- Set the request packet IPMI command code
++ *
++ *  SET_REQUEST_DATA(IPMI_XFER *, unsigned char *data, int length);
++ *    -- Set the request packet optional argument data field
++ * 
++ *  GET_RESPONSE_LUN(IPMI_XFER *, unsigned char lun);
++ *    -- Get the response packet logical unit
++ *
++ *  GET_RESPONSE_NETFN(IPMI_XFER *, unsigned char netfn);
++ *    -- Get the response packet network function code
++ * 
++ *  GET_RESPONSE_CMD(IPMI_XFER *, unsigned char cmd);
++ *    -- Get the response packet command
++ *
++ *  GET_RESPONSE_CC(IPMI_XFER *, unsigned char cc);
++ *    -- Get the response packet completion code
++ * 
++ *  GET_RESPONSE_DATA_LENGTH(IPMI_XFER *, int len);
++ *    -- Get the response packet data length
++ * 
++ *  GET_RESPONSE_DATA(IPMI_XFER *, unsigned char *buffer);
++ *    -- Copy the response packet data into local buffer
++ */
++
++#ifndef _IPMI_IOCTLS_H
++#define _IPMI_IOCTLS_H
++
++#define	IOCTL_IPMI_XFER		0x01
++#define	IOCTL_DRIVER_INFO	0x02
++
++typedef struct ipmi_xfer
++	{
++	unsigned char	request[64];
++	unsigned char	response[64];
++	int						request_len;
++	int						response_len;
++	} IPMI_XFER;
++
++struct ipmi_driver_info
++	{
++	char						driver_name[64];			/* Name of the driver */
++	int							major_ver;					
++	int							minor_ver;
++	unsigned short	mb_chipset_vendor;		/* PCI host bridge vendor tag */
++	unsigned short	mb_chipset_device;		/* PCI host bridge vendor device id */
++	unsigned int		flags;								/* driver specific flags */
++	unsigned int		reserved;
++	};
++
++/* flags definitions for the 'ipmi_kcs' driver */
++#define KCS_FLAG_BLINKY	0x01	/* Set if blinky works (only on Intel L440GX) */
++#define KCS_FLAG_LEGACY	0x02  /* Set if using legacy KCS interface ( < IPMI 1.0) */
++
++#define INIT_XFER(_xferp) \
++	memset(_xferp, 0, sizeof(IPMI_XFER)); \
++	_xferp->request_len = 2; \
++	_xferp->response_len = sizeof(_xferp->response);
++
++#define SET_REQUEST_LUN(_xferp, _lun) \
++	{ \
++	unsigned char _netfn_copy; \
++	\
++	_netfn_copy = (_xferp->request[0] & 0xFC); \
++	_xferp->request[0] = _lun; \
++	_xferp->request[0]|= _netfn_copy; \
++	}
++
++#define SET_REQUEST_NETFN(_xferp, netfn) \
++	{ \
++	unsigned char __lun_copy; \
++	\
++	__lun_copy = (_xferp->request[0] & 0x3); \
++	_xferp->request[0] = (netfn << 2); \
++	_xferp->request[0]|= __lun_copy; \
++	}
++
++#define SET_REQUEST_CMD(_xferp, _cmd) \
++	_xferp->request[1] = _cmd;
++
++#define SET_REQUEST_DATA(_xferp, datap, _len) \
++	{ \
++	memcpy(&_xferp->request[2], datap, _len); \
++	_xferp->request_len = (_len + 2); \
++	}
++
++#define GET_RESPONSE_LUN(_xferp, _lun) \
++	_lun = (_xferp->response[0] & 0x3);
++
++#define GET_RESPONSE_NETFN(_xferp, netfn) \
++	netfn = ((_xferp->response[0] & 0xFC) >> 2);
++
++#define GET_RESPONSE_CMD(_xferp, _cmd) \
++	_cmd = _xferp->response[1];
++
++#define GET_RESPONSE_CC(_xferp, cc) \
++	cc = _xferp->response[2];
++
++#define GET_RESPONSE_DATA_LENGTH(_xferp, _len) \
++	_len = (_xferp->response_len - 3);
++
++#define GET_RESPONSE_DATA(_xferp, datap) \
++	memcpy(datap, &_xferp->response[3], (_xferp->response_len -3));
++
++/*
++ * The Netfn codes
++ */
++#define CHASSIS_REQUEST   0x00
++#define CHASSIS_RESPONSE  0x01
++#define BRIDGE_REQUEST    0x02
++#define BRIDGE_RESPONSE   0x03
++#define SENSOR_REQUEST    0x04
++#define SENSOR_RESPONSE   0x05
++#define APP_REQUEST       0x06
++#define APP_RESPONSE      0x07
++#define FIRMWARE_REQUEST  0x08
++#define FIRMWARE_RESPONSE 0x09
++#define STORAGE_REQUEST   0x0A
++#define STORAGE_RESPONSE  0x0B
++
++#endif
+diff -urN linux-2.2.18.stock/include/linux/miscdevice.h linux-2.2.18/include/linux/miscdevice.h
+--- linux-2.2.18.stock/include/linux/miscdevice.h	Mon Aug  9 12:04:41 1999
++++ linux-2.2.18/include/linux/miscdevice.h	Fri Jan 26 18:31:37 2001
+@@ -26,6 +26,9 @@
+ #define SGI_STREAMS_KEYBOARD 150
+ /* drivers/sgi/char/usema.c */
+ #define SGI_USEMACLONE	     151
++#define IPMI_KCS_MINOR       173
++#define IPMI_BT_MINOR        210
++#define IPMI_SMIC_MINOR      211
+ 
+ extern int misc_init(void);
+ 
--- ipmi-ctl-2.0.orig/debian/changelog
+++ ipmi-ctl-2.0/debian/changelog
@@ -0,0 +1,38 @@
+ipmi-ctl (2.0-6) unstable; urgency=low
+
+  * Add modutils alias
+
+ -- Wichert Akkerman <wakkerma@debian.org>  Mon, 11 Jun 2001 16:06:59 +0200
+
+ipmi-ctl (2.0-5) unstable; urgency=low
+
+  * Make binary-arch target depend on build
+  * Escape dashes in ipmi_ctl.8
+  * Add dmidecode utility from Alan Cox
+
+ -- Wichert Akkerman <wakkerma@debian.org>  Wed, 16 May 2001 01:22:18 +0200
+
+ipmi-ctl (2.0-4) unstable; urgency=low
+
+  * Remove patch for 2.4 kernel, it doesn't work. Closes: Bug#96525
+
+ -- Wichert Akkerman <wakkerma@debian.org>  Tue,  8 May 2001 18:15:33 +0200
+
+ipmi-ctl (2.0-3) unstable; urgency=low
+
+  * Properly handle devfs. Closes: Bug#96308
+
+ -- Wichert Akkerman <wakkerma@debian.org>  Fri,  4 May 2001 14:44:30 +0200
+
+ipmi-ctl (2.0-2) unstable; urgency=low
+
+  * Install ipmi_ioctls.h in kernelpatch package
+
+ -- Wichert Akkerman <wakkerma@debian.org>  Thu,  3 May 2001 14:25:23 +0200
+
+ipmi-ctl (2.0-1) unstable; urgency=low
+
+  * Initial release
+
+ -- Wichert Akkerman <wakkerma@debian.org>  Sat, 28 Apr 2001 19:53:22 +0200
+
--- ipmi-ctl-2.0.orig/debian/ipmi-kcs.apply
+++ ipmi-ctl-2.0/debian/ipmi-kcs.apply
@@ -0,0 +1,46 @@
+#!/bin/sh
+#
+# Copyright 2001 Wichert Akkerman
+
+set -e
+
+thispatch=ipmi-kcs
+stamp=debian/APPLIED_i386_$thispatch
+patchdir=/usr/src/kernel-patches/i386/$thispatch
+
+if [ ! -d kernel -a -d Documentation ] ; then
+	echo "This does not seem to be a kernel source directory." >&2
+	exit 1
+fi
+
+if [ -f $stamp ] ; then
+	echo "The $thispatch patch is already applied"
+	exit 0
+fi
+
+version=$(sed -ne 's/^VERSION[[:space:]]\+=[[:space:]]\([^[:space:]]\+\).*/\1/p' Makefile)
+patchlevel=$(sed -ne 's/^PATCHLEVEL[[:space:]]\+=[[:space:]]\([^[:space:]]\+\).*/\1/p' Makefile)
+sublevel=$(sed -ne 's/^SUBLEVEL[[:space:]]\+=[[:space:]]\([^[:space:]]\+\).*/\1/p' Makefile)
+
+ps="$patchdir/$version.$patchlevel"
+pe="_$thispatch.patch"
+
+for ptc in "$ps.$sublevel$pe" "$ps$pe" ; do
+	if [ -f "$ptc" ] ; then
+		patch="$ptc"
+		echo "Will use $ptc to patch the kernel"
+		break
+	fi
+done
+
+if [ -z "$patch" ] ; then
+	echo "No $thispatch patch for this kernel found"
+	exit 1
+fi
+
+patch -p1 -s -l -N < "$patch"
+mkdir -p debian
+echo -n "$patch" > $stamp
+
+exit 0
+
--- ipmi-ctl-2.0.orig/debian/modutils
+++ ipmi-ctl-2.0/debian/modutils
@@ -0,0 +1 @@
+alias char-major-10-173 ipmi_kcs
--- ipmi-ctl-2.0.orig/debian/control
+++ ipmi-ctl-2.0/debian/control
@@ -0,0 +1,22 @@
+Source: ipmi-ctl
+Section: admin
+Priority: optional
+Maintainer: Wichert Akkerman <wakkerma@debian.org>
+Standards-Version: 3.5.3
+
+Package: kernel-patch-ipmi-kcs
+Architecture: i386
+Description: IPMI-KCS kernel patch
+ This packages contains the patches needed to allow the Linux kernel
+ to interface with the IPMI (Intelligent Platform Management Interface)
+ functionality of an Intel-based machine.
+
+Package: ipmi-control
+Architecture: i386
+Depends: ${shlibs:Depends}, makedev (>= 2.3.1-45) | devfsd
+Suggests: kernel-patch-ipmi-kcs
+Description: IPMI control tools
+ This package contains ipmi_ctl, a commandline tool to query and
+ manipulate the IPMI (Intelligent Platform Management Interface)
+ functionality of an Intel-based machine.
+
--- ipmi-ctl-2.0.orig/debian/ipmi-control.postinst
+++ ipmi-ctl-2.0/debian/ipmi-control.postinst
@@ -0,0 +1,24 @@
+#!/bin/sh
+
+set -e
+pkg=ipmi-control
+
+if [ ! "$1" = "configure" ] ; then
+	exit 0
+fi
+
+
+if [ ! -e /dev/ipmikcs -a ! -e /dev/.devfsd ] ; then
+	echo "Creating IPMI-KCS control device /dev/ipmikcs"
+	cd /dev
+	./MAKEDEV ipmi
+fi
+
+update-modules
+
+if [ -d /usr/doc -a ! -e /usr/doc/$pkg -a -d /usr/share/doc/$pkg ] ; then
+	ln -s ../share/doc/$pkg /usr/doc/$pkg
+fi
+
+exit 0
+
--- ipmi-ctl-2.0.orig/debian/copyright
+++ ipmi-ctl-2.0/debian/copyright
@@ -0,0 +1,20 @@
+
+This is the Debian GNU/Linux packaged version of the IPMI tools
+and drivers.
+
+The source was downloaded from the ipmitools project on sourceforge
+(http://sourceforge.net/projects.ipmitools/). The kernel patches
+were pulled from the CVS tree since they were not released separately.
+
+The IPMI tools and IPMI-KCS kernel driver are Copyright 1999 by
+San Mehat and VA Linux Systems, and licensed under the GNU General
+Public License as published by the Free Software Foundation, either
+version 2 of the License or any later version.
+
+The dmidecode utility is Copyright 2000,2001 Alan Cox and was
+downloaded from ftp://ftp.linux.org.uk/pub/linux/alan/DMI/ .
+
+On Debian system you can find the full text for the GNU GPL in
+/usr/share/common-licenses/GPL .
+
+
--- ipmi-ctl-2.0.orig/debian/Makefile
+++ ipmi-ctl-2.0/debian/Makefile
@@ -0,0 +1,501 @@
+VERSION = 2
+PATCHLEVEL = 2
+SUBLEVEL = 19
+EXTRAVERSION = +ext3+ipsec
+
+ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+
+.EXPORT_ALL_VARIABLES:
+
+CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
+	  else if [ -x /bin/bash ]; then echo /bin/bash; \
+	  else echo sh; fi ; fi)
+TOPDIR	:= $(shell if [ "$$PWD" != "" ]; then echo $$PWD; else pwd; fi)
+
+HPATH   	= $(TOPDIR)/include
+FINDHPATH	= $(HPATH)/asm $(HPATH)/linux $(HPATH)/scsi $(HPATH)/net
+
+HOSTCC  	=gcc
+HOSTCFLAGS	=-Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
+
+CROSS_COMPILE 	=
+
+AS	=$(CROSS_COMPILE)as
+LD	=$(CROSS_COMPILE)ld
+#
+#	foo-bar-gcc for cross builds
+#	gcc272 for Debian's old compiler for kernels
+#	kgcc for Conectiva, Mandrake and Red Hat 7
+#	otherwise 'cc'
+#
+CC	=$(shell if [ -n "$(CROSS_COMPILE)" ]; then echo $(CROSS_COMPILE)gcc; else \
+	$(CONFIG_SHELL) scripts/kwhich gcc272 2>/dev/null || $(CONFIG_SHELL) scripts/kwhich kgcc 2>/dev/null || echo cc; fi) \
+	-D__KERNEL__ -I$(HPATH)
+CPP	=$(CC) -E
+AR	=$(CROSS_COMPILE)ar
+NM	=$(CROSS_COMPILE)nm
+STRIP	=$(CROSS_COMPILE)strip
+OBJCOPY	=$(CROSS_COMPILE)objcopy
+OBJDUMP	=$(CROSS_COMPILE)objdump
+MAKE	=make
+GENKSYMS=/sbin/genksyms
+
+all:	do-it-all
+
+#
+# Make "config" the default target if there is no configuration file or
+# "depend" the target if there is no top-level dependency information.
+#
+ifeq (.config,$(wildcard .config))
+include .config
+ifeq (.depend,$(wildcard .depend))
+include .depend
+do-it-all:	Version vmlinux
+else
+CONFIGURATION = depend
+do-it-all:	depend
+endif
+else
+CONFIGURATION = config
+do-it-all:	config
+endif
+
+#
+# ROOT_DEV specifies the default root-device when making the image.
+# This can be either FLOPPY, CURRENT, /dev/xxxx or empty, in which case
+# the default of FLOPPY is used by 'build'.
+#
+
+ROOT_DEV = CURRENT
+
+KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
+
+#
+# INSTALL_PATH specifies where to place the updated kernel and system map
+# images.  Uncomment if you want to place them anywhere other than root.
+
+#INSTALL_PATH=/boot
+
+#
+# INSTALL_MOD_PATH specifies a prefix to MODLIB for module directory 
+# relocations required by build roots.  This is not defined in the
+# makefile but the argument can be passed to make if needed.
+#
+
+#
+# If you want to preset the SVGA mode, uncomment the next line and
+# set SVGA_MODE to whatever number you want.
+# Set it to -DSVGA_MODE=NORMAL_VGA if you just want the EGA/VGA mode.
+# The number is the same as you would ordinarily press at bootup.
+#
+
+SVGA_MODE=	-DSVGA_MODE=NORMAL_VGA
+
+#
+# standard CFLAGS
+#
+
+CFLAGS = -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
+
+# use '-fno-strict-aliasing', but only if the compiler can take it
+CFLAGS += $(shell if $(CC) -fno-strict-aliasing -S -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-fno-strict-aliasing"; fi)
+
+ifdef CONFIG_SMP
+CFLAGS += -D__SMP__
+AFLAGS += -D__SMP__
+endif
+
+#
+# if you want the RAM disk device, define this to be the
+# size in blocks.
+#
+
+#RAMDISK = -DRAMDISK=512
+
+# Include the make variables (CC, etc...)
+#
+
+CORE_FILES	=kernel/kernel.o mm/mm.o fs/fs.o ipc/ipc.o
+FILESYSTEMS	=fs/filesystems.a
+NETWORKS	=net/network.a
+DRIVERS		=drivers/block/block.a \
+		 drivers/char/char.o \
+	         drivers/misc/misc.a
+LIBS		=$(TOPDIR)/lib/lib.a
+SUBDIRS		=kernel drivers mm fs net ipc lib
+
+ifdef CONFIG_NUBUS
+DRIVERS := $(DRIVERS) drivers/nubus/nubus.a
+endif
+
+ifeq ($(CONFIG_ISDN),y)
+DRIVERS := $(DRIVERS) drivers/isdn/isdn.a
+endif
+
+DRIVERS := $(DRIVERS) drivers/net/net.a
+
+ifeq ($(CONFIG_SCSI),y)
+DRIVERS := $(DRIVERS) drivers/scsi/scsi.a
+endif
+
+ifneq ($(CONFIG_CD_NO_IDESCSI)$(CONFIG_BLK_DEV_IDECD)$(CONFIG_BLK_DEV_SR)$(CONFIG_PARIDE_PCD),)
+DRIVERS := $(DRIVERS) drivers/cdrom/cdrom.a
+endif
+
+ifeq ($(CONFIG_SOUND),y)
+DRIVERS := $(DRIVERS) drivers/sound/sounddrivers.o
+endif
+
+ifdef CONFIG_PCI
+DRIVERS := $(DRIVERS) drivers/pci/pci.a
+endif
+
+ifdef CONFIG_DIO
+DRIVERS := $(DRIVERS) drivers/dio/dio.a
+endif
+
+ifdef CONFIG_SBUS
+DRIVERS := $(DRIVERS) drivers/sbus/sbus.a
+endif
+
+ifdef CONFIG_ZORRO
+DRIVERS := $(DRIVERS) drivers/zorro/zorro.a
+endif
+
+ifeq ($(CONFIG_FC4),y)
+DRIVERS := $(DRIVERS) drivers/fc4/fc4.a
+endif
+
+ifeq ($(CONFIG_NET_FC),y)
+DRIVERS := $(DRIVERS) drivers/net/fc/fc.a
+endif
+
+ifdef CONFIG_POWERMAC
+DRIVERS := $(DRIVERS) drivers/macintosh/macintosh.o
+endif
+
+ifdef CONFIG_PNP
+DRIVERS := $(DRIVERS) drivers/pnp/pnp.a
+endif
+
+ifdef CONFIG_SGI
+DRIVERS := $(DRIVERS) drivers/sgi/sgi.a
+endif
+
+ifdef CONFIG_VT
+DRIVERS := $(DRIVERS) drivers/video/video.a
+endif
+
+ifeq ($(CONFIG_PARIDE),y)
+DRIVERS := $(DRIVERS) drivers/block/paride/paride.a
+endif
+
+ifdef CONFIG_HAMRADIO
+DRIVERS := $(DRIVERS) drivers/net/hamradio/hamradio.a
+endif
+
+ifeq ($(CONFIG_TC),y)
+DRIVERS := $(DRIVERS) drivers/tc/tc.a
+endif
+
+ifeq ($(CONFIG_USB),y)
+DRIVERS := $(DRIVERS) drivers/usb/usbdrv.o
+endif
+
+ifeq ($(CONFIG_I2O),y)
+DRIVERS := $(DRIVERS) drivers/i2o/i2o.a
+endif
+
+ifeq ($(CONFIG_IRDA),y)
+DRIVERS := $(DRIVERS) drivers/net/irda/irda_drivers.a
+endif
+
+ifeq ($(CONFIG_I2O),y)
+DRIVERS := $(DRIVERS) drivers/i2o/i2o.a
+endif
+
+ifeq ($(CONFIG_PHONE),y)
+DRIVERS := $(DRIVERS) drivers/telephony/telephony.a
+endif
+
+include arch/$(ARCH)/Makefile
+
+.S.s:
+	$(CC) -D__ASSEMBLY__ $(AFLAGS) -traditional -E -o $*.s $<
+.S.o:
+	$(CC) -D__ASSEMBLY__ $(AFLAGS) -traditional -c -o $*.o $<
+
+Version: dummy
+	@rm -f include/linux/compile.h
+
+boot: vmlinux
+	@$(MAKE) -C arch/$(ARCH)/boot
+
+vmlinux: $(CONFIGURATION) init/main.o init/version.o linuxsubdirs
+	$(LD) $(LINKFLAGS) $(HEAD) init/main.o init/version.o \
+		--start-group \
+		$(CORE_FILES) \
+		$(FILESYSTEMS) \
+		$(NETWORKS) \
+		$(DRIVERS) \
+		$(LIBS) \
+		--end-group \
+		-o vmlinux
+	$(NM) vmlinux | grep -v '\(compiled\)\|\(\.o$$\)\|\( [aU] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | sort > System.map
+
+symlinks:
+	rm -f include/asm
+	( cd include ; ln -sf asm-$(ARCH) asm)
+	@if [ ! -d modules ]; then \
+		mkdir modules; \
+	fi
+	@if [ ! -d include/linux/modules ]; then \
+		mkdir include/linux/modules; \
+	fi
+
+oldconfig: symlinks
+	$(CONFIG_SHELL) scripts/Configure -d arch/$(ARCH)/config.in
+
+xconfig: symlinks
+	$(MAKE) -C scripts kconfig.tk
+	wish -f scripts/kconfig.tk
+
+menuconfig: include/linux/version.h symlinks
+	$(MAKE) -C scripts/lxdialog all
+	$(CONFIG_SHELL) scripts/Menuconfig arch/$(ARCH)/config.in
+
+config: symlinks
+	$(CONFIG_SHELL) scripts/Configure arch/$(ARCH)/config.in
+
+include/config/MARKER: scripts/split-include include/linux/autoconf.h
+	scripts/split-include include/linux/autoconf.h include/config
+	@ touch include/config/MARKER
+
+linuxsubdirs: $(patsubst %, _dir_%, $(SUBDIRS))
+
+$(patsubst %, _dir_%, $(SUBDIRS)) : dummy include/config/MARKER
+	$(MAKE) -C $(patsubst _dir_%, %, $@)
+
+$(TOPDIR)/include/linux/version.h: include/linux/version.h
+$(TOPDIR)/include/linux/compile.h: include/linux/compile.h
+
+newversion:
+	@if [ ! -f .version ]; then \
+		echo 1 > .version; \
+	else \
+		expr 0`cat .version` + 1 > .version; \
+	fi
+
+include/linux/compile.h: $(CONFIGURATION) include/linux/version.h newversion
+	@echo -n \#define UTS_VERSION \"\#`cat .version` > .ver
+	@if [ -n "$(CONFIG_SMP)" ] ; then echo -n " SMP" >> .ver; fi
+	@if [ -f .name ]; then  echo -n \-`cat .name` >> .ver; fi
+	@echo ' '`LANG=C date`'"' >> .ver
+	@echo \#define LINUX_COMPILE_TIME \"`LANG=C date +%T`\" >> .ver
+	@echo \#define LINUX_COMPILE_BY \"`whoami`\" >> .ver
+	@echo \#define LINUX_COMPILE_HOST \"`hostname`\" >> .ver
+	@if [ -x /bin/dnsdomainname ]; then \
+	   echo \#define LINUX_COMPILE_DOMAIN \"`dnsdomainname`\"; \
+	 elif [ -x /bin/domainname ]; then \
+	   echo \#define LINUX_COMPILE_DOMAIN \"`domainname`\"; \
+	 else \
+	   echo \#define LINUX_COMPILE_DOMAIN ; \
+	 fi >> .ver
+	@echo \#define LINUX_COMPILER \"`$(CC) $(CFLAGS) -v 2>&1 | tail -1`\" >> .ver
+	@mv -f .ver $@
+
+include/linux/version.h: ./Makefile
+	@echo \#define UTS_RELEASE \"$(KERNELRELEASE)\" > .ver
+	@echo \#define LINUX_VERSION_CODE `expr $(VERSION) \\* 65536 + $(PATCHLEVEL) \\* 256 + $(SUBLEVEL)` >> .ver
+	@echo '#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))' >>.ver
+	@mv -f .ver $@
+
+init/version.o: init/version.c include/linux/compile.h include/config/MARKER
+	$(CC) $(CFLAGS) -DUTS_MACHINE='"$(ARCH)"' -c -o init/version.o init/version.c
+
+init/main.o: init/main.c include/config/MARKER
+	$(CC) $(CFLAGS) $(PROFILING) -c -o $*.o $<
+
+fs lib mm ipc kernel drivers net: dummy
+	$(MAKE) $(subst $@, _dir_$@, $@)
+
+MODFLAGS += -DMODULE
+ifdef CONFIG_MODULES
+ifdef CONFIG_MODVERSIONS
+MODFLAGS += -DMODVERSIONS -include $(HPATH)/linux/modversions.h
+endif
+
+modules: include/config/MARKER $(patsubst %, _mod_%, $(SUBDIRS))  
+
+$(patsubst %, _mod_%, $(SUBDIRS)) : include/linux/version.h
+	$(MAKE) -C $(patsubst _mod_%, %, $@) CFLAGS="$(CFLAGS) $(MODFLAGS)" MAKING_MODULES=1 modules
+
+modules_install:
+	@( \
+	MODLIB=$(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE); \
+	mkdir -p $$MODLIB; \
+	rm -f $$MODLIB/build; \
+	[ `/sbin/insmod -V 2>&1 | head -1 | awk '/^insmod version /{split($$3, a, /\./); printf "%d%03d%03d\n", a[1], a[2], a[3];}'`0 -ge 20030140 ] && \
+	ln -s `pwd` $$MODLIB/build; \
+	cd modules; \
+	MODULES=""; \
+	inst_mod() { These="`cat $$1`"; MODULES="$$MODULES $$These"; \
+		mkdir -p $$MODLIB/$$2; cp $$These $$MODLIB/$$2; \
+		echo Installing modules under $$MODLIB/$$2; \
+	}; \
+	\
+	if [ -f BLOCK_MODULES ]; then inst_mod BLOCK_MODULES block; fi; \
+	if [ -f NET_MODULES   ]; then inst_mod NET_MODULES   net;   fi; \
+	if [ -f IPV4_MODULES  ]; then inst_mod IPV4_MODULES  ipv4;  fi; \
+	if [ -f IPV6_MODULES  ]; then inst_mod IPV6_MODULES  ipv6;  fi; \
+	if [ -f SCSI_MODULES  ]; then inst_mod SCSI_MODULES  scsi;  fi; \
+	if [ -f FS_MODULES    ]; then inst_mod FS_MODULES    fs;    fi; \
+	if [ -f NLS_MODULES   ]; then inst_mod NLS_MODULES   fs;    fi; \
+	if [ -f CDROM_MODULES ]; then inst_mod CDROM_MODULES cdrom; fi; \
+	if [ -f HAM_MODULES   ]; then inst_mod HAM_MODULES   net;   fi; \
+	if [ -f SOUND_MODULES ]; then inst_mod SOUND_MODULES sound; fi; \
+	if [ -f VIDEO_MODULES ]; then inst_mod VIDEO_MODULES video; fi; \
+	if [ -f FC4_MODULES   ]; then inst_mod FC4_MODULES   fc4;   fi; \
+	if [ -f IRDA_MODULES  ]; then inst_mod IRDA_MODULES  net;   fi; \
+	if [ -f USB_MODULES   ]; then inst_mod USB_MODULES   usb;   fi; \
+	if [ -f USB_SERIAL_MODULES ]; then inst_mod USB_SERIAL_MODULES usb; fi; \
+	if [ -f SK98LIN_MODULES ]; then inst_mod SK98LIN_MODULES  net;   fi; \
+	if [ -f SKFP_MODULES ]; then inst_mod SKFP_MODULES   net;   fi; \
+	\
+	for f in *.o; do [ -r $$f ] && echo $$f; done | sort > $$MODLIB/.allmods; \
+	echo $$MODULES | tr ' ' '\n' | sort | comm -23 $$MODLIB/.allmods - > $$MODLIB/.misc; \
+	if [ -s $$MODLIB/.misc ]; then inst_mod $$MODLIB/.misc misc; fi; \
+	rm -f $$MODLIB/.misc $$MODLIB/.allmods; \
+	)
+
+# modules disabled....
+
+else
+modules modules_install: dummy
+	@echo
+	@echo "The present kernel configuration has modules disabled."
+	@echo "Type 'make config' and enable loadable module support."
+	@echo "Then build a kernel with module support enabled."
+	@echo
+	@exit 1
+endif
+
+clean:	archclean
+	rm -f kernel/ksyms.lst include/linux/compile.h
+	rm -f core `find . -name '*.[oas]' ! \( -regex '.*lxdialog/.*' \
+		-o -regex '.*ksymoops/.*' \) -print`
+	rm -f core `find . -type f -name 'core' -print`
+	rm -f core `find . -name '.*.flags' -print`
+	rm -f vmlinux System.map
+	rm -f .tmp*
+	rm -f drivers/char/consolemap_deftbl.c drivers/video/promcon_tbl.c
+	rm -f drivers/char/conmakehash
+	rm -f drivers/sound/bin2hex drivers/sound/hex2hex
+	if [ -d modules ]; then \
+		rm -f core `find modules/ -type f -print`; \
+	fi
+	rm -f submenu*
+
+mrproper: clean archmrproper
+	rm -f include/linux/autoconf.h include/linux/version.h
+	rm -f drivers/net/hamradio/soundmodem/sm_tbl_{afsk1200,afsk2666,fsk9600}.h
+	rm -f drivers/net/hamradio/soundmodem/sm_tbl_{hapn4800,psk4800}.h
+	rm -f drivers/net/hamradio/soundmodem/sm_tbl_{afsk2400_7,afsk2400_8}.h
+	rm -f drivers/net/hamradio/soundmodem/gentbl
+	rm -f drivers/char/hfmodem/gentbl drivers/char/hfmodem/tables.h
+	rm -f drivers/sound/*_boot.h drivers/sound/.*.boot
+	rm -f drivers/sound/msndinit.c
+	rm -f drivers/sound/msndperm.c
+	rm -f drivers/sound/pndsperm.c
+	rm -f drivers/sound/pndspini.c
+	rm -f .version .config* config.in config.old
+	rm -f scripts/tkparse scripts/kconfig.tk scripts/kconfig.tmp
+	rm -f scripts/lxdialog/*.o scripts/lxdialog/lxdialog
+	rm -f scripts/ksymoops/*.o scripts/ksymoops/ksymoops
+	rm -f .menuconfig.log
+	rm -f include/asm
+	rm -rf include/config
+	rm -f .depend `find . -name .depend -print`
+	rm -f core `find . -size 0 -print`
+	rm -f .hdepend scripts/mkdep scripts/split-include
+	rm -f $(TOPDIR)/include/linux/modversions.h
+	rm -rf $(TOPDIR)/include/linux/modules
+	rm -rf modules
+
+distclean: mrproper
+	rm -f core `find . \( -name '*.orig' -o -name '*.rej' -o -name '*~' \
+		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
+		-o -name '.*.rej' -o -name '.SUMS' -o -size 0 \) -print` TAGS
+
+backup: mrproper
+	cd .. && tar cf - linux/ | gzip -9 > backup.gz
+	sync
+
+sums:
+	find . -type f -print | sort | xargs sum > .SUMS
+
+dep-files: scripts/mkdep archdep include/linux/version.h new-genksyms
+	scripts/mkdep init/*.c > .depend
+	scripts/mkdep `find $(FINDHPATH) -follow -name \*.h ! -name modversions.h -print` > .hdepend
+#	set -e; for i in $(SUBDIRS); do $(MAKE) -C $$i fastdep ;done
+# let this be made through the fastdep rule in Rules.make
+	$(MAKE) $(patsubst %,_sfdep_%,$(SUBDIRS)) _FASTDEP_ALL_SUB_DIRS="$(SUBDIRS)"
+
+MODVERFILE :=
+
+ifdef CONFIG_MODVERSIONS
+
+MODVERFILE := $(TOPDIR)/include/linux/modversions.h
+
+new-genksyms:
+	@$(GENKSYMS) -k $(VERSION).$(PATCHLEVEL).$(SUBLEVEL) </dev/null \
+	2>/dev/null || ( echo -e "\nYou need a new version of the genksyms\
+	program, which is part of\nthe modutils package. Please read the file\
+	Documentation/Changes\nfor more information.\n"; exit 1 )
+
+else
+
+new-genksyms:
+
+endif
+
+depend dep: dep-files $(MODVERFILE)
+
+# make checkconfig: Prune 'scripts' directory to avoid "false positives".
+checkconfig:
+	perl -w scripts/checkconfig.pl `find * -path 'scripts' -prune -o -name '*.[hcS]' -print | sort`
+
+checkhelp:
+	perl -w scripts/checkhelp.pl `find * -name [cC]onfig.in -print`
+
+ifdef CONFIGURATION
+..$(CONFIGURATION):
+	@echo
+	@echo "You have a bad or nonexistent" .$(CONFIGURATION) ": running 'make" $(CONFIGURATION)"'"
+	@echo
+	$(MAKE) $(CONFIGURATION)
+	@echo
+	@echo "Successful. Try re-making (ignore the error that follows)"
+	@echo
+	exit 1
+
+#dummy: ..$(CONFIGURATION)
+dummy:
+
+else
+
+dummy:
+
+endif
+
+include Rules.make
+
+#
+# This generates dependencies for the .h files.
+#
+
+scripts/mkdep: scripts/mkdep.c
+	$(HOSTCC) $(HOSTCFLAGS) -o scripts/mkdep scripts/mkdep.c
+
+scripts/split-include: scripts/split-include.c
+	$(HOSTCC) $(HOSTCFLAGS) -o scripts/split-include scripts/split-include.c
--- ipmi-ctl-2.0.orig/debian/ipmi-control.conffiles
+++ ipmi-ctl-2.0/debian/ipmi-control.conffiles
@@ -0,0 +1 @@
+/etc/modutils/ipmi-control
--- ipmi-ctl-2.0.orig/debian/2.4.0_ipmi-kcs.patch
+++ ipmi-ctl-2.0/debian/2.4.0_ipmi-kcs.patch
@@ -0,0 +1,2470 @@
+diff -urN linux-2.4.0.stock/arch/i386/kernel/traps.c linux-2.4.0/arch/i386/kernel/traps.c
+--- linux-2.4.0.stock/arch/i386/kernel/traps.c	Wed Jan  3 20:45:26 2001
++++ linux-2.4.0/arch/i386/kernel/traps.c	Fri Jan 26 18:50:23 2001
+@@ -455,6 +455,14 @@
+ 
+ 
+ 	++nmi_count(smp_processor_id());
++#ifdef CONFIG_IPMI_KCS
++	if (reason & 0x20)
++		{
++		bmc_nmi_error(reason, regs);
++		return;
++		}
++#endif
++
+ 	if (!(reason & 0xc0)) {
+ #if CONFIG_X86_IO_APIC
+ 		/*
+@@ -484,6 +492,242 @@
+ 	outb(0x0f, 0x70);
+ 	inb(0x71);		/* dummy */
+ }
++
++#ifdef CONFIG_IPMI_KCS
++/*
++ * The IPMI KCS NMI watchdog handler stuff
++ */
++#include <linux/config.h>
++
++#define IO 0xca2
++#define ISA_BMC_STATUS    (IO + 1)
++#define ISA_BMC_COMMAND   (IO + 1)
++#define ISA_BMC_DATA_IN       (IO + 0)
++#define ISA_BMC_DATA_OUT      (IO + 0)
++#define ISA_STATE_MASK        0xC0
++#define ISA_IDLE_STATE        0x00
++#define ISA_READ_STATE        0x40
++#define ISA_WRITE_STATE       0x80
++#define ISA_ERROR_STATE       0xC0
++#define ISA_IBF_FLAG          0x02
++#define ISA_OBF_FLAG          0x01
++#define ISA_WRITE_START        0x61
++#define ISA_WRITE_END          0X62
++#define ISA_READ               0X68
++#define MAX_ISA_LENGTH  35
++#define ISA_TIMEOUT 1000
++
++static int get_wd_counter(void);
++static int kcs_read_message(int *msglen, unsigned char *buf);
++static int wait_while_ibf(int timeout);
++static int kcs_send_message(unsigned char *buf, int length);
++static void blink(void);
++
++static void bmc_nmi_error(unsigned char reason, struct pt_regs * regs)
++{
++  unsigned char           state;
++  volatile unsigned char  status;
++  unsigned int            wd_cnt;
++
++  /* First see if we were triggered by a BMC error */
++  status = inb_p(ISA_BMC_STATUS);
++  state = (unsigned char) (status & ISA_STATE_MASK);
++
++  if (state == ISA_ERROR_STATE)
++    {
++    printk("[KCS_TRAP] Called with ISA interface in error state\n");
++    return;
++    }
++  /* Now see if the watchdog timer is in danger of tripping */
++  if ((wd_cnt = get_wd_counter())<0)
++    {
++    printk("[KCS_TRAP] Unable to verify BMC WD status.\n");
++    blink();
++    return;
++    }
++  if (wd_cnt > 10)
++    {
++    printk("[KCS_TRAP] tripped due to recoverable BMC error (wd count = %d)\n",wd_cnt);
++    return;
++    }
++  printk("[KCS_TRAP] tripped due to imminent BMC watchdog trip (wd count = %d)\n",wd_cnt);
++  blink();
++  return;
++}
++
++static void blink()
++{
++  struct cmd
++    {
++    unsigned char lun   :2;
++    unsigned char netfn :6;
++
++    unsigned char cmd;
++    } pkt;
++  memset(&pkt, 0, sizeof(pkt));
++  pkt.lun=0x00;
++  pkt.netfn=0x06;
++  pkt.cmd=0x55;
++  kcs_send_message((unsigned char *) &pkt, sizeof(pkt));
++}
++
++static int get_wd_counter()
++{
++  unsigned char reply[MAX_ISA_LENGTH];
++  int           length;
++  struct get_watchdog_response
++    {
++    unsigned char cc           __attribute__ ((packed));
++
++    unsigned char timer_use    :3;
++    unsigned char res1         :3;
++    unsigned char timer_status :1;
++    unsigned char sel_log      :1;
++
++    unsigned char timeout_act  :3;
++    unsigned char res2         :1;
++    unsigned char pre_irq_act  :3;
++    unsigned char res3         :1;
++
++    unsigned char pre_timeout __attribute__ ((packed));
++
++    unsigned char timer_use_xp  __attribute__ ((packed));
++
++    unsigned short init_count  __attribute__ ((packed));
++    unsigned short current_count __attribute__ ((packed));
++    } *g_wd_response;
++  struct cmd
++    {
++    unsigned char lun   :2;
++    unsigned char netfn :6;
++
++    unsigned char cmd;
++    } pkt;
++
++  pkt.lun = 0;
++  pkt.netfn = 6;
++  pkt.cmd = 0x25;
++  kcs_send_message((unsigned char *) &pkt, sizeof(pkt));
++  /* Packet sent. now get the response */
++  if (kcs_read_message(&length, &reply[0])<0)
++    {
++    printk("[KCS_TRAP] Read Message failed\n");
++    return(-1);
++    }
++  if (reply[2] != 0x00)
++    {
++    printk("[KCS_TRAP] GET_WATCHDOG command failed (0x%x)\n",reply[2]);
++    return(-1);
++    }
++  g_wd_response= (struct get_watchdog_response *) &reply[2];
++  return(g_wd_response->current_count);
++}
++static int kcs_read_message(int *msglen, unsigned char *buf)
++{
++  int                      i;
++  unsigned char            state;
++  volatile unsigned char  status;
++
++  for (i=0; i < MAX_ISA_LENGTH; i++)
++    {
++    status = inb_p(ISA_BMC_STATUS);
++    while(!(status & ISA_OBF_FLAG))
++      {
++      status = inb_p(ISA_BMC_STATUS);
++      state = (unsigned char) (status & ISA_STATE_MASK);
++
++      if (state == ISA_ERROR_STATE)
++        {
++        printk("[KCS_TRAP] ISA interface in ERROR state\n");
++        return (-EIO);
++        }
++      else if (state == ISA_IDLE_STATE)
++        {
++        *msglen = i;
++        return(0);
++        }
++      }
++    buf[i] = inb_p(ISA_BMC_DATA_IN);
++    if (wait_while_ibf(ISA_TIMEOUT))
++      {
++      printk("[KCS_TRAP] ISA timeout in IBF\n");
++      return(-EIO);
++      }
++    outb_p(ISA_READ, ISA_BMC_DATA_OUT);
++    }
++  printk("[KCS_TRAP] ISA Message overflow\n");
++  return (-EIO);
++}
++
++static int wait_while_ibf(int timeout)
++{
++  unsigned int master_timeout=5;
++  unsigned char status_byte;
++
++  status_byte = (inb_p(ISA_BMC_STATUS) & 0xFF);
++  while(status_byte & ISA_IBF_FLAG)
++    {
++    master_timeout--;
++    if (!master_timeout)
++      return(-1);
++    udelay(100);
++    status_byte = (inb_p(ISA_BMC_STATUS) & 0xFF);
++    }
++  return(0);
++}
++
++static int kcs_send_message(unsigned char *buf, int length)
++{
++  int           status;
++  int           i;
++  unsigned char chipstatus;
++
++  if ((status = wait_while_ibf(ISA_TIMEOUT)) <0)
++    return(-EIO);
++
++  outb_p(ISA_WRITE_START, ISA_BMC_COMMAND);
++
++  if ((status = wait_while_ibf(ISA_TIMEOUT)) <0)
++    return(-EIO);
++
++  for (i=0; i <length -1; i++)
++    {
++    chipstatus = inb_p(ISA_BMC_STATUS);
++
++    if (chipstatus & ISA_OBF_FLAG)
++      inb_p(ISA_BMC_DATA_IN);
++
++    if ((chipstatus & ISA_STATE_MASK) != ISA_WRITE_STATE)
++      {
++      printk("[KCS_TRAP] ISA write state fault (0x%x)\n",chipstatus);
++      return(-EIO);
++      }
++    outb_p(buf[i], ISA_BMC_DATA_OUT);
++    if ((status = wait_while_ibf(ISA_TIMEOUT)) <0)
++      return(-EIO);
++    }
++  outb_p(ISA_WRITE_END, ISA_BMC_COMMAND);
++  if ((status = wait_while_ibf(ISA_TIMEOUT)) <0)
++    return(-EIO);
++  outb_p(buf[i], ISA_BMC_DATA_OUT);
++  if ((status = wait_while_ibf(ISA_TIMEOUT)) <0)
++    return(-EIO);
++
++  chipstatus = inb_p(ISA_BMC_STATUS);
++  if ((chipstatus & ISA_STATE_MASK) !=ISA_READ_STATE)
++    {
++    printk("[KCS_TRAP] ISA read state fault (0x%x)\n",chipstatus);
++    return (-EIO);
++    }
++  return(0);
++}
++/* END of KCS watchdog trap handler */
++#endif
++
++
++
++
++
+ 
+ /*
+  * Our handling of the processor debug registers is non-trivial.
+diff -urN linux-2.4.0.stock/drivers/char/Config.in linux-2.4.0/drivers/char/Config.in
+--- linux-2.4.0.stock/drivers/char/Config.in	Fri Dec 29 14:07:21 2000
++++ linux-2.4.0/drivers/char/Config.in	Fri Jan 26 18:46:03 2001
+@@ -81,6 +81,8 @@
+    dep_tristate 'Support for user-space parallel port device drivers' CONFIG_PPDEV $CONFIG_PARPORT
+ fi
+ 
++tristate 'IPMI KCS Interface' CONFIG_IPMI_KCS
++
+ source drivers/i2c/Config.in
+ 
+ mainmenu_option next_comment
+diff -urN linux-2.4.0.stock/drivers/char/Makefile linux-2.4.0/drivers/char/Makefile
+--- linux-2.4.0.stock/drivers/char/Makefile	Thu Jan  4 13:00:55 2001
++++ linux-2.4.0/drivers/char/Makefile	Fri Jan 26 20:18:43 2001
+@@ -97,6 +97,8 @@
+   obj-$(CONFIG_PCI) += keyboard.o $(KEYMAP)
+ endif
+ 
++
++
+ obj-$(CONFIG_MAGIC_SYSRQ) += sysrq.o
+ obj-$(CONFIG_ATARI_DSP56K) += dsp56k.o
+ obj-$(CONFIG_ROCKETPORT) += rocket.o
+@@ -169,6 +171,8 @@
+ obj-$(CONFIG_DZ) += dz.o
+ obj-$(CONFIG_NWBUTTON) += nwbutton.o
+ obj-$(CONFIG_NWFLASH) += nwflash.o
++
++obj-$(CONFIG_IPMI_KCS) += ipmi_kcs.o
+ 
+ # Only one watchdog can succeed. We probe the hardware watchdog
+ # drivers first, then the softdog driver.  This means if your hardware
+diff -urN linux-2.4.0.stock/drivers/char/ipmi_kcs.c linux-2.4.0/drivers/char/ipmi_kcs.c
+--- linux-2.4.0.stock/drivers/char/ipmi_kcs.c	Wed Dec 31 16:00:00 1969
++++ linux-2.4.0/drivers/char/ipmi_kcs.c	Fri Jan 26 21:39:49 2001
+@@ -0,0 +1,980 @@
++/*
++ *  Intelligent Platform Management Interface driver for Linux 2.2.x
++ *
++ *  (c) Copyright 2000 San Mehat <nettwerk@valinux.com>, All Rights Reserved.
++ *        http://www.valinux.com
++ *
++ *  This program is free software; you can redistribute it and/or
++ *  modify it under the terms of the GNU General Public License
++ *  as published by the Free Software Foundation; either version
++ *  2 of the License, or (at your option) any later version.
++ *  
++ *  Neither San Mehat nor VA Linux Systems admit liability nor provide 
++ *  warranty for any of this software. This material is provided 
++ *  "AS-IS" and at no charge.  
++ *
++ *  (c) Copyright 1999    San Mehat <nettwerk@valinux.com>
++ *
++ *  Release 0.04.   - Initial Release
++ *  
++ *  Release 0.05.   - Fixed ring buffer bugs... better buffer handling
++ *
++ *  Release 0.06.   - Changed polling freq to 1/10 sec
++ *
++ *  Release 0.07.   - Integrated watchdog commands into IOCTL's and added
++ *                    support for blinking front panel LED
++ *
++ *  Release 0.08.   - Sensor read commands added as ioctl
++ *
++ *  Release 0.09.   - Changed polling freq back to 1 second
++ *                  - Fixed possible bug where a chip status variable was
++ *                    not declared volatile.
++ *                  - Fixed buffer memory leak
++ *                  - Fixed ioctl return value problem
++ *                  - Changed architecture so that applications calling
++ *                    driver ioctl()'s are put to sleep after request
++ *                    is sent. The reply is handled by the normal
++ *                    driver polling timer queue and ring buffer
++ *
++ *  Release 0.10.   - Modified kcs_write routine so once a write is complete
++ *                    if the interface isn't in a 'READ STATE' it's okay.
++ *
++ *  Release 0.12.   - Added Intel Nightshade MB fixups since NS boards don't
++ *                    support pre-timeout NMI support
++ *                  - FRU download support added
++ *                  - /proc/ipmi created with fru data and driver status
++ *  Release 0.13.   - Added ioctl for setting asset tag
++ *                  - Fixed bug in /proc
++ *                  - Added asset tag max length field
++ *  Release 1.00    - Added intelligent proc reading so that asset tag is
++ *                    refreshed whenever /proc/ipmi is read
++ *                  - Code cleanup
++ *                  - When asset tag is set with data whoes size is < maximum,
++ *                    pad the rest out with NULLs
++ *  Release 1.10    - Fixed SMP bug which was causing command failures when
++ *                    /proc/ipmi was being read while a command was being 
++ *                    executed (added semaphore)
++ *                  - Fixed /proc/ipmi so commands only get issued once
++ *  Release 1.20    - Removed a bunch of useless warning msgs
++ *  Release 1.30    - Added more stringent error checking when ISA state
++ *                    enters ERROR_STATE
++ *                  - Added better unexpected OBF handling on transactions
++ *                  - Explicitly set power sensor state to NO BLINKY on 
++ *                    startup
++ *  Release 2.0     - Re-wrote kcs state machine
++ *                  - Removed high level functions from driver
++ *                  - removed driver read() and write() capabilities
++ *                  - /proc/ipmi renamed to /proc/ipmi_kcs
++ *                  - /proc/ipmi_kcs now contains only BMC info
++ *                    
++ */
++
++#include <linux/config.h>
++#include <linux/module.h>
++#include <linux/version.h>
++#include <linux/types.h>
++#include <linux/errno.h>
++#include <linux/kernel.h>
++#include <linux/sched.h>
++#include <linux/miscdevice.h>
++#include "ipmi_kcs.h"
++#include <linux/malloc.h>
++#include <linux/ioport.h>
++#include <linux/fcntl.h>
++#include <asm/io.h>
++#include <asm/uaccess.h>
++#include <asm/system.h>
++#include <asm/semaphore.h>
++#include <linux/reboot.h>
++#include <linux/init.h>
++#include <linux/delay.h>
++#include <linux/timer.h>
++#include <linux/ipmi_ioctls.h>
++#include <linux/pci.h>
++
++#ifdef CONFIG_PROC_FS
++#include <linux/proc_fs.h>
++#endif
++
++/* function prototypes */
++
++int ipmi_kcs_init(void);
++
++static int kcs_open(struct inode	*inode,
++										struct file		*file);
++static int kcs_release(	struct inode	*inode,
++												struct file		*file);
++static ssize_t kcs_read(struct file *file,
++												char				*buf,
++												size_t			count,
++												loff_t			*ptr);
++static ssize_t kcs_write(	struct file	*file,
++													const char	*buf,
++													size_t			count,
++													loff_t			*ppos);
++static long long kcs_llseek(struct file	*file,
++														long long		offset,
++														int					origin);
++static int kcs_ioctl(	struct inode	*inode,
++											struct file		*file,
++											unsigned int	cmd,
++											unsigned long	arg);
++
++static unsigned char get_kcs_state(void);
++static unsigned char read_kcs_data(void);
++static void write_kcs_data(unsigned char data);
++static void write_kcs_cmd(unsigned char	cmd);
++static int is_obf_set(void);
++static int clear_obf(void);
++static int wait_while_ibf(void);
++static int get_deviceid(void);
++static int kcs_do_xfer(	BMC_REQUEST		*request,
++												int						request_len,
++												BMC_RESPONSE	*response,
++												int						*response_len);
++static int old_kcs_do_xfer(	BMC_REQUEST		*request,
++														int						request_len,
++														BMC_RESPONSE	*response,
++														int						*response_len);
++static int new_kcs_do_xfer(	BMC_REQUEST		*request,
++														int						request_len,
++														BMC_RESPONSE	*response,
++														int						*response_len);
++
++#ifdef CONFIG_PROC_FS
++int ipmi_get_info(char *buf, char **start, off_t fpos, int length, int *eof, void *unused);
++#endif
++
++/* static globals */
++static int					kcs_refcnt=0;
++static int					driver_major = 2;
++static int					driver_minor = 0;
++static int					kcs_machine  = 0;
++
++static struct
++	{
++	unsigned int	tx_good;
++	unsigned int	tx_bad;
++	} kcs_stat;
++
++static DEVICE_ID_RESPONSE	dev_id;
++DECLARE_MUTEX(kcs_sem);
++
++#ifdef CONFIG_PROC_FS
++static struct proc_dir_entry *ipmi_proc_entry;
++#endif
++
++static struct file_operations kcs_fops = {
++		owner:		THIS_MODULE,
++		write:		kcs_write,
++		ioctl:		kcs_ioctl,
++		open:			kcs_open,
++		release:	kcs_release,
++		read:			kcs_read,
++};
++
++static struct miscdevice kcs_miscdev=
++{
++  IPMI_KCS_MINOR,
++  "ipmi_kcs",
++  &kcs_fops
++};
++
++static struct ipmi_driver_info drv_inf;
++
++/***************/
++
++static long long kcs_llseek(struct file *file, long long offset, int origin)
++{
++  return -ESPIPE;
++}
++
++static ssize_t kcs_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
++{
++	return (-ENOSYS);
++}
++
++static ssize_t kcs_read(struct file *file, char *buf, size_t count, loff_t *ptr)
++{
++	return (-ENOSYS);
++}
++
++static int kcs_ioctl(struct inode  *inode,
++                     struct file   *file,
++                     unsigned int  cmd,
++                     unsigned long arg)
++{
++  switch(cmd)
++    {
++		case IOCTL_IPMI_XFER:
++			{
++			IPMI_XFER	user_buffer;
++			int				rc;
++			int				response_len = sizeof(user_buffer.response);
++
++			if (!arg)
++				return(-EFAULT);
++			if (copy_from_user((void *) &user_buffer, (void *) arg, sizeof(IPMI_XFER)))
++				return(-EFAULT);
++			if ((user_buffer.request_len < 2) || (user_buffer.response_len < 3))
++				return(-EINVAL);
++			
++			rc = kcs_do_xfer( (BMC_REQUEST *) &user_buffer.request,
++												user_buffer.request_len,
++												(BMC_RESPONSE *) &user_buffer.response,
++												&response_len);
++			user_buffer.response_len = response_len;
++			copy_to_user((void *) arg, (void *) &user_buffer, sizeof(IPMI_XFER));
++			return(rc);
++			}
++		case IOCTL_DRIVER_INFO:
++			{
++			struct ipmi_driver_info	user_buffer;
++
++			if (!arg)
++				return(-EFAULT);
++			if (copy_from_user((void *) &user_buffer, (void *) arg, sizeof(user_buffer)))
++				return(-EFAULT);
++			copy_to_user((void *) arg, (void *) &drv_inf, sizeof(drv_inf));
++			return(0);
++			}
++		default:
++    	return -EINVAL;
++    }
++  return (0);
++}
++
++static int get_deviceid()
++{
++	unsigned char	request_buffer[MAX_BUFFER_SIZE];
++	unsigned char	response_buffer[MAX_BUFFER_SIZE];
++	BMC_REQUEST		*bmc_req;
++	BMC_RESPONSE	*bmc_resp;
++	int						rc, response_len;
++
++	memset(&dev_id, 0, sizeof(DEVICE_ID_RESPONSE));
++	memset(request_buffer, 0, sizeof(request_buffer));
++	memset(response_buffer, 0, sizeof(response_buffer));
++	bmc_req = (BMC_REQUEST *) request_buffer;
++	bmc_resp= (BMC_RESPONSE *) response_buffer;
++	response_len = sizeof(response_buffer);
++
++	bmc_req->lun = 0;
++	bmc_req->netfn = APP_REQUEST;
++	bmc_req->cmd = 0x01; /* GET_DEVICE_ID */
++
++	rc = old_kcs_do_xfer(	bmc_req,
++												2,
++												bmc_resp,
++												&response_len);
++	if (bmc_resp->cc != 0x00)
++		{
++		printk("[IPMI_KCS] get_deviceid() failed (0x%.2x)\n",bmc_resp->cc);
++		return(-EIO);
++		}
++	memcpy(&dev_id, bmc_resp->data, sizeof(DEVICE_ID_RESPONSE));
++  return(0);
++}
++
++static int kcs_open(struct inode *inode, struct file *file)
++{
++  switch(MINOR(inode->i_rdev))
++    {
++    case IPMI_KCS_MINOR:
++      {
++      MOD_INC_USE_COUNT;
++      kcs_refcnt++;
++      return 0;
++      }
++    default:
++      return -ENODEV;
++    }
++}
++
++static int kcs_release(struct inode *inode, struct file *file)
++{
++  if(MINOR(inode->i_rdev)==IPMI_KCS_MINOR)
++		{
++    kcs_refcnt--;
++		}
++  MOD_DEC_USE_COUNT;
++  return 0;
++}
++
++#ifdef MODULE
++int	init_module(void)
++{
++  return(ipmi_kcs_init());
++}
++
++void cleanup_module(void)
++{
++  printk("[IPMI_KCS] Driver shutting down.\n");
++#ifdef CONFIG_PROC_FS
++	remove_proc_entry("ipmi_kcs", 0);
++#endif
++  misc_deregister(&kcs_miscdev);
++  release_region(KCS_BASE,16);
++}
++#endif
++
++int ipmi_kcs_init()
++{
++  printk("IPMI KCS driver (San Mehat nettwerk@valinux.com) v%d.%d at io 0x%x\n",
++          driver_major,
++          driver_minor,
++          KCS_BASE);
++  request_region(KCS_BASE, 16, "ipmi_kcs");
++  if ((inb_p(KCS_STATUS_REG) == 0xFF) &&
++      (inb_p(KCS_DATAIN_REG) == 0xFF))
++    {
++    printk("--KCS ISA window not present. Driver exiting\n");
++    release_region(KCS_BASE,16);
++    return(-ENXIO);
++    }
++	
++	kcs_stat.tx_good = 0;
++	kcs_stat.tx_bad = 0;
++	memset(&drv_inf, 0, sizeof(drv_inf));
++	strcpy(drv_inf.driver_name, "ipmi_kcs");
++	drv_inf.major_ver = driver_major;
++	drv_inf.minor_ver = driver_minor;
++
++  misc_register(&kcs_miscdev);
++  get_deviceid();
++  printk("--BMC version %x.%x, IPMI version %d.%d\n",
++          dev_id.major_firmware_revision,
++          dev_id.minor_firmware_revision,
++          dev_id.ipmi_version_major,
++          dev_id.ipmi_version_minor);
++	if ((dev_id.ipmi_version_major == 0) &&
++			(dev_id.ipmi_version_minor == 9))
++		{
++		printk("--Using legacy KCS state machine\n");
++		kcs_machine = KCS_LEGACY;
++		drv_inf.flags |= KCS_FLAG_LEGACY;
++		}
++	else
++		{
++		printk("--Using new KCS state machine\n");
++		kcs_machine = KCS_NEW;
++		}
++	if (!pci_present())
++		{
++		printk("--PCIBIOS not present. Unable to determine chipset vendor\n");
++		drv_inf.flags |= KCS_FLAG_BLINKY;
++		}
++	else
++		{
++		int							pci_index = 0;
++		unsigned char		pci_bus, pci_device_fn;
++		unsigned short	vendor, device;
++
++		for (;pci_index < 0xff; pci_index++)
++			{
++			if (pcibios_find_class(PCI_CLASS_BRIDGE_HOST << 8, 
++														 pci_index,
++														 &pci_bus,
++														 &pci_device_fn) != PCIBIOS_SUCCESSFUL)
++				{
++				break;
++				}
++			pcibios_read_config_word(pci_bus, pci_device_fn,
++															 PCI_VENDOR_ID, &vendor);
++			pcibios_read_config_word(pci_bus, pci_device_fn,
++															 PCI_DEVICE_ID, &device);
++			drv_inf.mb_chipset_vendor = vendor;
++			drv_inf.mb_chipset_device = device;
++			printk("--Motherboard Chipset vendor 0x%.4x, device 0x%.4x\n",
++						vendor, device);
++			if ((vendor == 0x8086) &&
++					(device == 0x71a0))
++				{
++				drv_inf.flags |= KCS_FLAG_BLINKY;
++				}
++			}
++		}
++	if (drv_inf.flags & KCS_FLAG_BLINKY)
++		{
++		printk("--Intel Lancewood features enabled\n");
++		}
++	else
++		printk("--No vendor specific features enabled\n");
++#ifdef CONFIG_PROC_FS
++	if (!(ipmi_proc_entry = create_proc_entry("ipmi_kcs",0, 0)))
++		printk(KERN_ERR,"--ERROR: Unable to register /proc/ipmi_kcs\n");
++	else
++		ipmi_proc_entry->read_proc = ipmi_get_info;
++	
++#endif
++  return(0);
++}
++
++static int kcs_do_xfer(	BMC_REQUEST		*request,
++												int						request_len,
++												BMC_RESPONSE	*response,
++												int						*response_len)
++{
++	int	rc = 0;
++
++	down(&kcs_sem);
++	switch(kcs_machine)
++		{
++		case KCS_LEGACY:
++			{
++			rc = old_kcs_do_xfer(request, request_len, response, response_len);
++			break;
++			}
++		case KCS_NEW:
++			{
++			rc = new_kcs_do_xfer(request, request_len, response, response_len);
++			break;
++			}
++		default:
++			{
++			printk("[IPMI_KCS] Undefined or bad KCS state machine selected (%d)\n",
++							kcs_machine);
++			get_deviceid();
++			if ((dev_id.ipmi_version_major == 0) &&
++				(dev_id.ipmi_version_minor == 9))
++				{
++				printk("Recalibrated to use legacy KCS state machine\n");
++				kcs_machine = KCS_LEGACY;
++				}
++			else
++				{
++				printk("Recalibrated to use new KCS state machine\n");
++				kcs_machine = KCS_NEW;
++				}
++			rc = -EAGAIN;
++			break;
++			}
++		}
++	if (rc == 0)
++		kcs_stat.tx_good ++;
++	else
++		kcs_stat.tx_bad ++;
++	up(&kcs_sem);
++	return(rc);
++}
++
++static int new_kcs_do_xfer(	BMC_REQUEST		*request,
++														int						request_len,
++														BMC_RESPONSE	*response,
++														int						*response_len)
++{
++	unsigned char	*xmit_buffer, *recv_buffer;
++	int						i = 0, rc = 0, state = SEND_INIT, bad = 0;
++
++	xmit_buffer = (unsigned char *) request;
++	recv_buffer = (unsigned char *) response;
++
++	while(1)
++		{
++		if (state == END)
++			break;
++		else if (bad > 2)
++			{
++			printk("[IPMI_KCS] Maximum retries exceeded. Aborting transfer\n");
++			rc = -EIO;
++			break;
++			}
++		switch (state)
++			{
++			case SEND_INIT:
++				{
++				i = 0;
++				state = SEND_START;
++				wait_while_ibf();
++				if (clear_obf() != 0)
++					{
++					state = ERROR;
++					break;
++					}
++				}
++			case SEND_START:
++				{
++				state = SEND_NEXT;
++				write_kcs_cmd(WRITE_START);
++				wait_while_ibf();
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				}
++			case SEND_NEXT:
++				{
++				if (i == (request_len -1))
++					{
++					state = SEND_END;
++					break;
++					}
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				write_kcs_data(xmit_buffer[i++]);
++				wait_while_ibf();
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				if (clear_obf() != 0)
++					{
++					state = ERROR;
++					break;
++					}
++				break;
++				}
++			case SEND_END:
++				{
++				write_kcs_cmd(WRITE_END);
++				wait_while_ibf();
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				if (clear_obf()!= 0)
++					{
++					state = ERROR;
++					break;
++					}
++				write_kcs_data(xmit_buffer[i++]);
++				wait_while_ibf();
++				state = RECV_START;
++				}
++			case RECV_START:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_WRITE_STATE:
++					case KCS_IDLE_STATE:
++						{
++						mdelay(BMC_RESPONSE_DELAY);
++						break;
++						}
++					case KCS_READ_STATE:
++						{
++						i = 0;
++						memset(recv_buffer, 0, *response_len);
++						state = RECV_INIT;
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_INIT:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++					case KCS_WRITE_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_IDLE_STATE:
++						{
++						state = RECV_END;
++						break;
++						}
++					case KCS_READ_STATE:
++						{
++						if (is_obf_set())
++							state = RECV_NEXT;
++						else
++							mdelay(1);
++						break;
++						}
++					default:
++						{
++						mdelay(1);
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_NEXT:
++				{
++				if (i >= *response_len)
++					{
++					rc = -EOVERFLOW;
++					state = ERROR;
++					break;
++					}
++				recv_buffer[i++] = read_kcs_data();
++				write_kcs_data(KCS_READ);
++				wait_while_ibf();
++				state = RECV_INIT2;
++				break;
++				}
++			case RECV_INIT2:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++					case KCS_WRITE_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_IDLE_STATE:
++						{
++						if (wait_until_obf() == 0)
++							{
++							clear_obf();
++							state = RECV_END;
++							break;
++							}
++						else
++							{
++							state = ERROR;
++							break;
++							}
++						}
++					case KCS_READ_STATE:
++						{
++						if (wait_until_obf() == 0)
++							state = RECV_NEXT;
++						else
++							state = ERROR;
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_END:
++				{
++				if ((i < MIN_BMC_RESPONSE_SIZE) ||
++						(response->netfn != (request->netfn | 0x01)) ||
++						(response->cmd   != request->cmd))
++					{
++					mdelay(BMC_RETRY_DELAY);
++					bad++;
++					state = SEND_INIT;
++					printk("[IPMI_KCS] Request/Response CMD/NETFN mismatch error\n");
++		
++					printk("           RQcmd/RQnetfn=0x%x/0x%x,RScmd/RSnetfn=0x%x/0x%x\n",
++									request->cmd, request->netfn, response->cmd, response->netfn);
++					break;
++					}
++		
++				*response_len = i;
++				rc = 0;
++				state = END;
++				break;
++				}
++			case ERROR:
++			default:
++				{
++				printk("[IPMI_KCS] BMC in bad state. Retrying transfer\n");
++				mdelay(BMC_RETRY_DELAY);
++				bad++;
++				state = SEND_INIT;
++				break;
++				}
++			}
++		}
++	return(rc);
++}
++
++static int old_kcs_do_xfer(	BMC_REQUEST		*request,
++														int						request_len,
++														BMC_RESPONSE	*response,
++														int						*response_len)
++{
++	unsigned char	*xmit_buffer, *recv_buffer;
++	int						i = 0, rc = 0, state = SEND_INIT, bad = 0;
++
++	xmit_buffer = (unsigned char *) request;
++	recv_buffer = (unsigned char *) response;
++
++	while(1)
++		{
++		if (state == END)
++			break;
++		else if (bad > 2)
++			{
++			printk("[IPMI_KCS] Maximum retries exceeded. Aborting transfer\n");
++			rc = -EIO;
++			break;
++			}
++		switch (state)
++			{
++			case SEND_INIT:
++				{
++				i = 0;
++				state = SEND_START;
++				wait_while_ibf();
++				}
++			case SEND_START:
++				{
++				state = SEND_NEXT;
++				write_kcs_cmd(WRITE_START);
++				wait_while_ibf();
++				}
++			case SEND_NEXT:
++				{
++				if (i == (request_len -1))
++					{
++					state = SEND_END;
++					break;
++					}
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				write_kcs_data(xmit_buffer[i++]);
++				wait_while_ibf();
++				break;
++				}
++			case SEND_END:
++				{
++				wait_while_ibf();
++				write_kcs_cmd(WRITE_END);
++				wait_while_ibf();
++				if (get_kcs_state() != KCS_WRITE_STATE)
++					{
++					state = ERROR;
++					break;
++					}
++				write_kcs_data(xmit_buffer[i++]);
++				wait_while_ibf();
++				state = RECV_START;
++				}
++			case RECV_START:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_WRITE_STATE:
++					case KCS_IDLE_STATE:
++						{
++						mdelay(BMC_RESPONSE_DELAY);
++						break;
++						}
++					case KCS_READ_STATE:
++						{
++						i = 0;
++						memset(recv_buffer, 0, *response_len);
++						state = RECV_INIT;
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_INIT:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++					case KCS_WRITE_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_IDLE_STATE:
++						{
++						state = RECV_END;
++						break;
++						}
++					case KCS_READ_STATE:
++						{
++						if (is_obf_set())
++							state = RECV_NEXT;
++						else
++							mdelay(1);
++						break;
++						}
++					default:
++						{
++						mdelay(1);
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_NEXT:
++				{
++				if (i >= *response_len)
++					{
++					rc = -EOVERFLOW;
++					state = ERROR;
++					break;
++					}
++				recv_buffer[i++] = read_kcs_data();
++				wait_while_ibf();
++				write_kcs_data(KCS_READ);
++				state = RECV_INIT2;
++				break;
++				}
++			case RECV_INIT2:
++				{
++				switch (get_kcs_state())
++					{
++					case KCS_ERROR_STATE:
++					case KCS_WRITE_STATE:
++						{
++						state = ERROR;
++						break;
++						}
++					case KCS_IDLE_STATE:
++						{
++						state = RECV_END;
++						break;
++						}
++					case KCS_READ_STATE:
++						{
++						if (is_obf_set())
++							state = RECV_NEXT;
++						break;
++						}
++					}
++				break;
++				}
++			case RECV_END:
++				{
++				if ((i < MIN_BMC_RESPONSE_SIZE) ||
++						(response->netfn != (request->netfn | 0x01)) ||
++						(response->cmd   != request->cmd))
++					{
++					mdelay(BMC_RETRY_DELAY);
++					bad++;
++					state = SEND_INIT;
++					printk("[IPMI_KCS] Request/Response CMD/NETFN mismatch error\n");
++		
++					printk("           RQcmd/RQnetfn=0x%x/0x%x,RScmd/RSnetfn=0x%x/0x%x\n",
++									request->cmd, request->netfn, response->cmd, response->netfn);
++					break;
++					}
++		
++				*response_len = i;
++				rc = 0;
++				state = END;
++				break;
++				}
++			case ERROR:
++			default:
++				{
++				printk("[IPMI_KCS] BMC in bad state. Retrying transfer\n");
++				mdelay(BMC_RETRY_DELAY);
++				bad++;
++				state = SEND_INIT;
++				break;
++				}
++			}
++		}
++	return(rc);
++}
++	
++#ifdef CONFIG_PROC_FS
++int ipmi_get_info(char *buf, char **start, off_t fpos, int length, int *eof, void *unused)
++{
++  char    *p;
++
++ 	if (get_deviceid()!= 0)
++   	{
++   	printk("[IPMI_KCS] Unable to get device ID\n");
++   	memset(&dev_id, 0, sizeof(dev_id));
++   	}
++
++  p = buf;
++  p+= sprintf(p, "Driver Version\t: %d.%d\n",
++              driver_major,driver_minor);
++  p+=sprintf(p, "BMC Version\t: %x.%x\n",
++            dev_id.major_firmware_revision,
++            dev_id.minor_firmware_revision);
++  p+=sprintf(p, "IPMI Version\t: %d.%d\n",
++            dev_id.ipmi_version_major,
++            dev_id.ipmi_version_minor);
++	p+=sprintf(p, "\nTotal Good Transactions\t: %d\n",kcs_stat.tx_good);
++	p+=sprintf(p, "Total Bad Transactions\t: %d\n",kcs_stat.tx_bad);
++
++  return p - buf;
++}
++#endif
++
++/*
++ * kcs chip mashing stuff
++ */
++static int wait_while_ibf()
++{
++  unsigned char status_byte;
++
++ 	status_byte = inb_p(KCS_STATUS_REG);
++	if ((status_byte & KCS_IBF)== 0)
++		return(0);
++	mdelay(KCS_READY_DELAY);
++ 	status_byte = inb_p(KCS_STATUS_REG);
++	if (status_byte & KCS_IBF)
++		return(-1);
++	return(0);
++}
++
++static int wait_until_obf()
++{
++	int	retries = 0;
++
++	while(retries < 2)
++		{
++		if (is_obf_set())
++			return(0);
++		mdelay(KCS_READY_DELAY);
++		retries++;
++		}
++  return(-ETIMEDOUT);
++}
++
++static unsigned char get_kcs_state()
++{
++	unsigned char cs;
++
++	cs = inb_p(KCS_STATUS_REG);
++	return(cs & KCS_STATE_MASK);
++}
++
++static unsigned char read_kcs_data()
++{
++	unsigned char	data;
++
++	data = inb_p(KCS_DATAOUT_REG);
++	return(data);
++}
++
++static void write_kcs_data(unsigned char	data)
++{
++  outb_p(data, KCS_DATAIN_REG);
++}
++
++static void write_kcs_cmd(unsigned char	cmd)
++{
++  outb_p(cmd, KCS_COMMAND_REG);
++}
++
++static int is_obf_set()
++{
++	unsigned char cs;
++
++	cs = inb_p(KCS_STATUS_REG);
++	return((cs & KCS_OBF) == KCS_OBF);
++}
++
++static int clear_obf()
++{
++	read_kcs_data();
++	return(0);
++}
+diff -urN linux-2.4.0.stock/drivers/char/ipmi_kcs.h linux-2.4.0/drivers/char/ipmi_kcs.h
+--- linux-2.4.0.stock/drivers/char/ipmi_kcs.h	Wed Dec 31 16:00:00 1969
++++ linux-2.4.0/drivers/char/ipmi_kcs.h	Fri Jan 26 18:44:13 2001
+@@ -0,0 +1,123 @@
++/*
++ *  Intelligent Platform Management Interface driver for Linux 2.x
++ *
++ *  (c) Copyright 1999  San Mehat & VA Linux Systems
++ *        1382 Bordeaux Dr.
++ *        Sunnyvale, California
++ *        94089
++ *
++ *  http://www.valinux.com
++ *
++ *  This driver is provided under the GNU public license, incorporated
++ *  herein by reference. The driver is provided without warranty or
++ *  support.
++ *
++ *
++ */
++
++#include <linux/config.h>
++
++#define KCS_LEGACY					1
++#define KCS_NEW							2
++
++#define KCS_READY_DELAY			5
++#define BMC_RESPONSE_DELAY	5
++#define BMC_RETRY_DELAY			60
++
++#define KCS_BASE 					0xca2
++#define KCS_STATUS_REG    (KCS_BASE + 1)
++#define KCS_COMMAND_REG   (KCS_BASE + 1)
++#define KCS_DATAIN_REG    (KCS_BASE + 0)
++#define KCS_DATAOUT_REG   (KCS_BASE + 0)
++
++/* State bits based on S1 & S0 below */
++#define KCS_STATE_MASK        0xC0
++#define KCS_IDLE_STATE        0x00
++#define KCS_READ_STATE        0x40
++#define KCS_WRITE_STATE       0x80
++#define KCS_ERROR_STATE       0xC0
++
++#define KCS_IBF								0x02
++#define KCS_OBF								0x01
++#define KCS_SMS_ATN						0x04
++
++#define SEND_INIT				1
++#define SEND_START			2
++#define SEND_NEXT				3
++#define SEND_END				4
++#define RECV_START			5
++#define RECV_INIT				6
++#define RECV_NEXT				7
++#define RECV_INIT2			8
++#define RECV_END				9
++#define END							10
++#define ERROR						0
++
++/* SMS Transfer Stream Control Codes */
++#define GET_STATUS_ABORT   0x60
++#define WRITE_START	0x61
++#define WRITE_END		0x62
++#define KCS_READ		0x68
++
++#define MAX_INVALID_RESPONSE_COUNT    2
++#define MIN_BMC_RESPONSE_SIZE         3
++#define MAX_IMB_PACKET_SIZE           33
++#define MAX_BMC_RESPONSE_SIZE (MIN_BMC_RESPONSE_SIZE + MAX_IMB_PACKET_SIZE)
++#define MAX_XFER_LENGTH               (MAX_IMB_PACKET_SIZE * 2)                 
++
++#define MAX_BUFFER_SIZE								64
++
++typedef struct bmc_response
++	{
++  unsigned char lun               :2;
++  unsigned char netfn             :6;
++
++  unsigned char cmd;
++	unsigned char	cc;
++	unsigned char	data[1];
++	}BMC_RESPONSE;
++
++typedef struct bmc_request
++	{
++  unsigned char lun               :2;
++  unsigned char netfn             :6;
++
++  unsigned char cmd;
++	unsigned char	data[1];
++	}BMC_REQUEST;
++
++/* GET_DEVICE_ID RESPONSE */
++typedef struct device_id_response
++  {
++  unsigned char device_id;
++  
++  unsigned char device_revision         :4;
++  unsigned char reserved                :3;
++  unsigned char provides_sdr            :1;
++  
++  unsigned char major_firmware_revision :7;
++  #define NORMAL_OPERATION  0
++  #define DEVICE_BUSY       1
++  unsigned char device_available        :1;
++  
++  unsigned char minor_firmware_revision;
++  
++  unsigned char ipmi_version_major      :4;
++  unsigned char ipmi_version_minor      :4;
++  
++  unsigned char supports_sensor_device  :1;
++  unsigned char supports_sdr_device     :1;
++  unsigned char supports_sel_device     :1;
++  unsigned char supports_fru_device     :1;
++  unsigned char supports_ipmb_receiver  :1;
++  unsigned char supports_ipmb_generator :1;
++  unsigned char supports_bridge         :1;
++  unsigned char supports_chassis_device :1;
++  
++  unsigned char manufacturer_id1;
++  unsigned char manufacturer_id2;
++  unsigned char manufacturer_id3;
++  
++  unsigned short product_id;
++  } DEVICE_ID_RESPONSE;
++
+diff -urN linux-2.4.0.stock/drivers/char/misc.c linux-2.4.0/drivers/char/misc.c
+--- linux-2.4.0.stock/drivers/char/misc.c	Mon Oct 16 12:58:51 2000
++++ linux-2.4.0/drivers/char/misc.c	Fri Jan 26 18:47:18 2001
+@@ -289,6 +289,11 @@
+ #ifdef CONFIG_TOSHIBA
+ 	tosh_init();
+ #endif
++
++#ifdef CONFIG_IPMI_KCS
++	ipmi_kcs_init();
++#endif
++
+ 	if (devfs_register_chrdev(MISC_MAJOR,"misc",&misc_fops)) {
+ 		printk("unable to get major %d for misc devices\n",
+ 		       MISC_MAJOR);
+diff -urN linux-2.4.0.stock/include/linux/ipmi_ioctls.h linux-2.4.0/include/linux/ipmi_ioctls.h
+--- linux-2.4.0.stock/include/linux/ipmi_ioctls.h	Wed Dec 31 16:00:00 1969
++++ linux-2.4.0/include/linux/ipmi_ioctls.h	Fri Jan 26 18:44:13 2001
+@@ -0,0 +1,152 @@
++/*
++ *  Intelligent Platform Management Interface driver for Linux 2.x
++ *
++ *  (c) Copyright 1999  San Mehat & VA Linux Systems
++ *        1382 Bordeaux Dr.
++ *        Sunnyvale, California
++ *        94089
++ *
++ *  http://www.valinux.com
++ *
++ *  This driver is provided under the GNU public license, incorporated
++ *  herein by reference. The driver is provided without warranty or
++ *  support.
++ *
++ *  IOCTL definitions for IPMI drivers
++ */
++
++/*
++ * Note: The following macros should be used on the IPMI_XFER structure.
++ *       DO NOT try to muck with this structure directly.. use the macros
++ *       to ensure future compatibility:
++ *
++ *  INIT_XFER(IPMI_XFER *);  
++ *    -- Zero out a IPMI_XFER structure and initialize it for use
++ *
++ *  SET_REQUEST_LUN(IPMI_XFER *, unsigned char lun);
++ *    -- Set the request packet logical unit
++ *
++ *  SET_REQUEST_NETFN(IPMI_XFER *, unsigned char netfn);
++ *    -- Set the request packet network function code
++ *
++ *  SET_REQUEST_CMD(IPMI_XFER *, unsigned char cmd);
++ *    -- Set the request packet IPMI command code
++ *
++ *  SET_REQUEST_DATA(IPMI_XFER *, unsigned char *data, int length);
++ *    -- Set the request packet optional argument data field
++ * 
++ *  GET_RESPONSE_LUN(IPMI_XFER *, unsigned char lun);
++ *    -- Get the response packet logical unit
++ *
++ *  GET_RESPONSE_NETFN(IPMI_XFER *, unsigned char netfn);
++ *    -- Get the response packet network function code
++ * 
++ *  GET_RESPONSE_CMD(IPMI_XFER *, unsigned char cmd);
++ *    -- Get the response packet command
++ *
++ *  GET_RESPONSE_CC(IPMI_XFER *, unsigned char cc);
++ *    -- Get the response packet completion code
++ * 
++ *  GET_RESPONSE_DATA_LENGTH(IPMI_XFER *, int len);
++ *    -- Get the response packet data length
++ * 
++ *  GET_RESPONSE_DATA(IPMI_XFER *, unsigned char *buffer);
++ *    -- Copy the response packet data into local buffer
++ */
++
++#ifndef _IPMI_IOCTLS_H
++#define _IPMI_IOCTLS_H
++
++#define	IOCTL_IPMI_XFER		0x01
++#define	IOCTL_DRIVER_INFO	0x02
++
++typedef struct ipmi_xfer
++	{
++	unsigned char	request[64];
++	unsigned char	response[64];
++	int						request_len;
++	int						response_len;
++	} IPMI_XFER;
++
++struct ipmi_driver_info
++	{
++	char						driver_name[64];			/* Name of the driver */
++	int							major_ver;					
++	int							minor_ver;
++	unsigned short	mb_chipset_vendor;		/* PCI host bridge vendor tag */
++	unsigned short	mb_chipset_device;		/* PCI host bridge vendor device id */
++	unsigned int		flags;								/* driver specific flags */
++	unsigned int		reserved;
++	};
++
++/* flags definitions for the 'ipmi_kcs' driver */
++#define KCS_FLAG_BLINKY	0x01	/* Set if blinky works (only on Intel L440GX) */
++#define KCS_FLAG_LEGACY	0x02  /* Set if using legacy KCS interface ( < IPMI 1.0) */
++
++#define INIT_XFER(_xferp) \
++	memset(_xferp, 0, sizeof(IPMI_XFER)); \
++	_xferp->request_len = 2; \
++	_xferp->response_len = sizeof(_xferp->response);
++
++#define SET_REQUEST_LUN(_xferp, _lun) \
++	{ \
++	unsigned char _netfn_copy; \
++	\
++	_netfn_copy = (_xferp->request[0] & 0xFC); \
++	_xferp->request[0] = _lun; \
++	_xferp->request[0]|= _netfn_copy; \
++	}
++
++#define SET_REQUEST_NETFN(_xferp, netfn) \
++	{ \
++	unsigned char __lun_copy; \
++	\
++	__lun_copy = (_xferp->request[0] & 0x3); \
++	_xferp->request[0] = (netfn << 2); \
++	_xferp->request[0]|= __lun_copy; \
++	}
++
++#define SET_REQUEST_CMD(_xferp, _cmd) \
++	_xferp->request[1] = _cmd;
++
++#define SET_REQUEST_DATA(_xferp, datap, _len) \
++	{ \
++	memcpy(&_xferp->request[2], datap, _len); \
++	_xferp->request_len = (_len + 2); \
++	}
++
++#define GET_RESPONSE_LUN(_xferp, _lun) \
++	_lun = (_xferp->response[0] & 0x3);
++
++#define GET_RESPONSE_NETFN(_xferp, netfn) \
++	netfn = ((_xferp->response[0] & 0xFC) >> 2);
++
++#define GET_RESPONSE_CMD(_xferp, _cmd) \
++	_cmd = _xferp->response[1];
++
++#define GET_RESPONSE_CC(_xferp, cc) \
++	cc = _xferp->response[2];
++
++#define GET_RESPONSE_DATA_LENGTH(_xferp, _len) \
++	_len = (_xferp->response_len - 3);
++
++#define GET_RESPONSE_DATA(_xferp, datap) \
++	memcpy(datap, &_xferp->response[3], (_xferp->response_len -3));
++
++/*
++ * The Netfn codes
++ */
++#define CHASSIS_REQUEST   0x00
++#define CHASSIS_RESPONSE  0x01
++#define BRIDGE_REQUEST    0x02
++#define BRIDGE_RESPONSE   0x03
++#define SENSOR_REQUEST    0x04
++#define SENSOR_RESPONSE   0x05
++#define APP_REQUEST       0x06
++#define APP_RESPONSE      0x07
++#define FIRMWARE_REQUEST  0x08
++#define FIRMWARE_RESPONSE 0x09
++#define STORAGE_REQUEST   0x0A
++#define STORAGE_RESPONSE  0x0B
++
++#endif
+diff -urN linux-2.4.0.stock/include/linux/miscdevice.h linux-2.4.0/include/linux/miscdevice.h
+--- linux-2.4.0.stock/include/linux/miscdevice.h	Thu Jan  4 14:50:49 2001
++++ linux-2.4.0/include/linux/miscdevice.h	Fri Jan 26 20:53:54 2001
+@@ -30,6 +30,9 @@
+ #define SGI_STREAMS_KEYBOARD 150
+ /* drivers/sgi/char/usema.c */
+ #define SGI_USEMACLONE	     151
++#define IPMI_KCS_MINOR       173
++#define IPMI_BT_MINOR        210
++#define IPMI_SMIC_MINOR      211
+ 
+ #define TUN_MINOR	     200
+ 
+Binary files linux-2.4.0.stock/ipmi_ctl and linux-2.4.0/ipmi_ctl differ
+diff -urN linux-2.4.0.stock/ipmi_ctl.c linux-2.4.0/ipmi_ctl.c
+--- linux-2.4.0.stock/ipmi_ctl.c	Wed Dec 31 16:00:00 1969
++++ linux-2.4.0/ipmi_ctl.c	Fri Jan 26 21:42:20 2001
+@@ -0,0 +1,706 @@
++#include <stdio.h>
++#include <sys/types.h>
++#include <errno.h>
++#include <fcntl.h>
++#include <linux/ipmi_ioctls.h>
++#include "ipmi_ctl.h"
++
++static void decode_string(unsigned char type,
++                          unsigned char language_code,
++                          unsigned char *source,
++                          char          *target,
++                          int           size);
++int	report_device_id(int fd);
++int	enable_watchdog(int fd);
++int	disable_watchdog(int fd);
++int	pet_watchdog(int fd);
++int	query_watchdog(int fd);
++int load_fru(int fd);
++int driver_info(int fd);
++int set_asset(int fd, char *asset_tag);
++int set_blink(int fd, int state);
++void display_fru(void);
++void usage(char *progname);
++
++DEVICE_ID_RESPONSE	dev_id;
++extern char					*optarg;
++extern int					opterr;
++extern int					optopt;
++
++int main(argc, argv)
++char **argv;
++{
++	int	fd, rc;
++	int	mode = 0;
++
++	if ((fd = open("/dev/ipmi/kcs", O_RDWR))<0)
++		{
++		perror("open");
++		exit(-1);
++		}
++	if (argc < 2)
++		{
++		usage(argv[0]);
++		exit(-1);
++		}
++	printf("IPMI CTL Version 1.0, (c) 2001 San Mehat (nettwerk@valinux.com)\n");
++	report_device_id(fd);
++	while((rc = getopt(argc, argv, "rspdqvfa:b:"))!=EOF)
++		{
++		if ((char) rc == 'a')
++			{
++			char	*asset_tag;
++		
++			asset_tag = (char *) strdup(optarg);
++			set_asset(fd, asset_tag);
++			free(asset_tag);
++			exit(0);
++			}
++		if ((char) rc == 'r')
++			{
++			}
++		else if ((char) rc == 's')
++			{
++			enable_watchdog(fd);
++			exit(0);
++			}
++		else if ((char) rc == 'p')
++			{
++			pet_watchdog(fd);
++			exit(0);
++			}
++		else if ((char) rc == 'd')
++			{
++			disable_watchdog(fd);
++			exit(0);
++			}
++		else if ((char) rc == 'q')
++			{
++			query_watchdog(fd);
++			exit(0);
++			}
++		else if ((char) rc == 'b')
++			{
++			char	*state;
++			state = (char *) strdup(optarg);
++			if (state[0] == '1')
++				set_blink(fd, 1);
++			else if (state[0] == '0')
++				set_blink(fd, 0);
++			else
++				{
++				printf("Blink state must be 1 or 0\n");
++				exit(-1);
++				}
++			free(state);
++			}
++		else if ((char) rc == 'v')
++			{
++			driver_info(fd);
++			exit(0);
++			}
++		else if ((char) rc == 'f')
++			{
++			load_fru(fd);
++			display_fru();
++			exit(0);
++			}
++		else
++			{
++			usage(argv[0]);
++			exit(-1);
++			}
++		}
++
++	close(fd);
++	exit(0);
++}
++
++int set_blink(int fd, int state)
++{
++	struct ipmi_driver_info	drv_inf;
++	IPMI_XFER								xfer;
++	IPMI_XFER								*xferp = &xfer;
++	unsigned char						cc;
++	int											rc;
++
++	memset(&drv_inf, 0, sizeof(drv_inf));
++	if (ioctl(fd, IOCTL_DRIVER_INFO, (void *) &drv_inf)<0)
++		{
++		printf("set_blink(): failed (%m)\n");
++		return(-1);
++		}
++	
++	if (!strcasecmp(drv_inf.driver_name, "ipmi_kcs"))
++		{
++		if (!(drv_inf.flags & KCS_FLAG_BLINKY))
++			{
++			printf("blink not available on this hardware\n");
++			return(-1);
++			}
++		}
++	else
++		{
++		printf("blink support not implimented for this driver\n");
++		return(-1);
++		}
++	INIT_XFER(xferp);
++	SET_REQUEST_LUN(xferp, 0);
++	SET_REQUEST_NETFN(xferp, APP_REQUEST);
++	if (state == 1)
++		{
++		SET_REQUEST_CMD(xferp, 0x55);
++		}
++	else
++		{
++		SET_REQUEST_CMD(xferp, 0x56);
++		}
++	if ((rc = ioctl(fd, IOCTL_IPMI_XFER, (void *) &xfer))<0)
++		{
++		printf("set_blink(): failed (%m)\n");
++		return(-1);
++		}
++	GET_RESPONSE_CC(xferp, cc);
++
++	if (cc != 0x00)
++		{
++		printf("set_blink(): failed (cc = 0x%.2x)\n",cc);
++		return(-1);
++		}
++	return(0);
++}
++
++int driver_info(int fd)
++{
++	struct ipmi_driver_info	drv_inf;
++
++	memset(&drv_inf, 0, sizeof(drv_inf));
++	if (ioctl(fd, IOCTL_DRIVER_INFO, (void *) &drv_inf)<0)
++		{
++		printf("driver_info(): failed (%m)\n");
++		return(-1);
++		}
++	printf("IPMI driver name : %s\n",drv_inf.driver_name);
++	printf("Driver Version   : %d.%d\n",drv_inf.major_ver, drv_inf.minor_ver);
++	printf("MB Chipset Vendor: 0x%.4x\n",drv_inf.mb_chipset_vendor);
++	printf("MB Chipset Device: 0x%.4x\n",drv_inf.mb_chipset_device);
++	printf("Driver Flags     : ");
++	if (!strcasecmp(drv_inf.driver_name, "ipmi_kcs"))
++		{
++		if (drv_inf.flags & KCS_FLAG_BLINKY)
++			printf("BLINKY ");
++		if (drv_inf.flags & KCS_FLAG_LEGACY)
++			printf("LEGACY_MACHINE ");
++		else
++			printf("NEW_MACHINE ");
++		printf("\n");
++		}
++	else
++		printf("(not implimented for this driver)\n");
++	return(0);
++}
++
++/*
++ * Watchdog related code
++ */
++int	enable_watchdog(int fd)
++{
++	int						rc;
++	IPMI_XFER			xfer;
++	IPMI_XFER			*xferp = &xfer;
++	SET_WATCHDOG	set;
++	unsigned char	cc;
++	int						fixup = 0;
++
++	while(1)
++		{
++		memset(&set, 0, sizeof(set));
++
++		set.timer_use = 0x04;
++		set.timeout_action = 0x03;
++		if (fixup)
++			{
++			set.pre_irq = 0x00;
++			set.pretimeout_interval = 0;
++			}
++		else
++			{
++			set.pre_irq = 0x03;
++			set.pretimeout_interval = 10;
++			}
++		set.tuefc_smsos= 0x01;
++		set.initial_count = (30*10);
++
++		INIT_XFER(xferp);
++		SET_REQUEST_LUN(xferp, 0);
++		SET_REQUEST_NETFN(xferp, APP_REQUEST);
++		SET_REQUEST_CMD(xferp, CMD_WATCHDOG_SET);
++		SET_REQUEST_DATA(xferp, (unsigned char *) &set, sizeof(set));
++
++		if ((rc = ioctl(fd, IOCTL_IPMI_XFER, (void *) &xfer))<0)
++			{
++			printf("enable_watchdog(): failed (%m)\n");
++			return(-1);
++			}
++		GET_RESPONSE_CC(xferp, cc);
++		if (cc == 0xcc)
++			{
++			fixup++;
++			if (fixup ==2)
++				{
++				printf("Flakey NMI fixup failed\n");
++				return(-1);
++				}
++			printf("Flakey NMI fixup enabled\n");
++			}
++		else if (cc != 0x00)
++			{
++			printf("enable_watchdog(): failed (cc = 0x%.2x)\n",cc);
++			return(-1);
++			}
++		break;
++		}
++	return(0);
++}
++
++int	disable_watchdog(int fd)
++{
++	int						rc;
++	IPMI_XFER			xfer;
++	IPMI_XFER			*xferp = &xfer;
++	SET_WATCHDOG	set;
++	unsigned char	cc;
++
++	memset(&set, 0, sizeof(set));
++
++	set.timer_use = 0x04;
++	set.timeout_action = 0x00;
++	set.pre_irq = 0x00;
++	set.pretimeout_interval = 10;
++	set.tuefc_smsos= 0x01;
++	set.initial_count = (30*10);
++
++	INIT_XFER(xferp);
++	SET_REQUEST_LUN(xferp, 0);
++	SET_REQUEST_NETFN(xferp, APP_REQUEST);
++	SET_REQUEST_CMD(xferp, CMD_WATCHDOG_SET);
++	SET_REQUEST_DATA(xferp, (unsigned char *) &set, sizeof(set));
++
++	if ((rc = ioctl(fd, IOCTL_IPMI_XFER, (void *) &xfer))<0)
++		{
++		printf("disable_watchdog(): failed (%m)\n");
++		return(-1);
++		}
++	GET_RESPONSE_CC(xferp, cc);
++	if (cc != 0x00)
++		{
++		printf("disable_watchdog(): failed (cc = 0x%.2x)\n",cc);
++		return(-1);
++		}
++	return(0);
++}
++
++int query_watchdog(int fd)
++{
++	GET_WATCHDOG_RESPONSE	resp;
++	IPMI_XFER							xfer;
++	IPMI_XFER							*xferp = &xfer;
++	int										rc;
++	unsigned char					cc;
++
++	INIT_XFER(xferp);
++	SET_REQUEST_LUN(xferp, 0);
++	SET_REQUEST_NETFN(xferp, APP_REQUEST);
++	SET_REQUEST_CMD(xferp, CMD_WATCHDOG_GET);
++
++	if ((rc = ioctl(fd, IOCTL_IPMI_XFER, (void *) &xfer))<0)
++		{
++		printf("query_watchdog(): failed (%m)\n");
++		return(-1);
++		}
++
++	GET_RESPONSE_CC(xferp, cc);
++	if (cc != 0x00)
++		{
++		printf("enable_watchdog(): failed (cc = 0x%.2x)\n",cc);
++		return(-1);
++		}
++	memset(&resp, 0, sizeof(resp));
++
++	GET_RESPONSE_DATA(xferp, (unsigned char *) &resp);
++	printf("Watchdog initial count : %d\n",resp.init_count);
++	printf("Watchdog current count : %d\n",resp.current_count);
++	
++	printf("Watchdog timeout action: %d (%s)\n",resp.timeout_act,
++					(	(resp.timeout_act == 0x00) ? "Disabled" :
++						(resp.timeout_act == 0x01) ? "Hard Reset" :
++						(resp.timeout_act == 0x02) ? "Power Down" :
++						(resp.timeout_act == 0x03) ? "Power Cycle" : "Unknown"));
++	return(0);
++}
++
++int	pet_watchdog(int fd)
++{
++	IPMI_XFER			xfer;
++	IPMI_XFER			*xferp = &xfer;
++	int						rc;
++	unsigned char	cc;
++
++	INIT_XFER(xferp);
++	SET_REQUEST_LUN(xferp, 0);
++	SET_REQUEST_NETFN(xferp, APP_REQUEST);
++	SET_REQUEST_CMD(xferp, CMD_WATCHDOG_RESET);
++
++	if ((rc = ioctl(fd, IOCTL_IPMI_XFER, (void *) &xfer))<0)
++		{
++		printf("report_device_id(): failed (%m)\n");
++		return(-1);
++		}
++
++	GET_RESPONSE_CC(xferp, cc);
++	if (cc != 0x00)
++		{
++		printf("pet_watchdog(): failed (cc = 0x%.2x)\n",cc);
++		return(-1);
++		}
++	return(0);
++}
++
++/*
++ * Device ID related code
++ */
++int	report_device_id(int fd)
++{
++	IPMI_XFER						xfer;
++	IPMI_XFER						*xferp = &xfer;
++	int									rc;
++	unsigned char				cc;
++
++	INIT_XFER(xferp);
++	SET_REQUEST_LUN(xferp, 0);
++	SET_REQUEST_NETFN(xferp, APP_REQUEST);
++	SET_REQUEST_CMD(xferp, CMD_GET_DEVICE_ID);
++
++	if ((rc = ioctl(fd, IOCTL_IPMI_XFER, (void *) &xfer))<0)
++		{
++		printf("report_device_id(): failed (%m)\n");
++		return(-1);
++		}
++
++	GET_RESPONSE_CC(xferp, cc);
++	if (cc != 0x00)
++		{
++		printf("report_device_id(): failed (cc = 0x%.2x)\n",cc);
++		return(-1);
++		}
++	memset(&dev_id, 0, sizeof(dev_id));
++	GET_RESPONSE_DATA(xferp, (unsigned char *) &dev_id);
++	printf("BMC version %x.%x, IPMI version %d.%d\n",
++					dev_id.major_firmware_revision,
++					dev_id.minor_firmware_revision,
++					dev_id.ipmi_version_major,
++					dev_id.ipmi_version_minor);
++	return(0);
++}
++
++/*
++ * FRU related code
++ */
++char					board_area[BOARD_AREA_NUM_FIELDS][64];
++char					product_area[PRODUCT_AREA_NUM_FIELDS][64];
++int						asset_offset = -1;
++int						asset_length = 0;
++int						asset_lang = 0;
++int						fru_size = 0;
++
++void display_fru()
++{
++	printf("Mainboard FRU Size  : %d\n",fru_size);
++	printf("Board Manufacturer  : %s\n",(board_area[BOARD_MANUFACTURER][0] ? board_area[BOARD_MANUFACTURER] : "Not Available"));
++	printf("Board Product Name  : %s\n",(board_area[BOARD_PRODUCT_NAME][0] ? board_area[BOARD_PRODUCT_NAME] : "Not Available"));
++	printf("Board Part Number   : %s\n",(board_area[BOARD_PART][0] ? board_area[BOARD_PART] : "Not Available"));
++	printf("Board Serial #      : %s\n",(board_area[BOARD_SERIAL][0] ? board_area[BOARD_SERIAL] : "Not Available"));
++
++	printf("Product Manufacturer: %s\n",(product_area[PRODUCT_MANUFACTURER][0] ? product_area[PRODUCT_MANUFACTURER] : "Not Available"));
++	printf("Product Name        : %s\n",(product_area[PRODUCT_NAME][0] ? product_area[PRODUCT_NAME] : "Not Available"));
++	printf("Product Part Number : %s\n",(product_area[PRODUCT_PART][0] ? product_area[PRODUCT_PART] : "Not Available"));
++	printf("Product Version     : %s\n",(product_area[PRODUCT_VERSION][0] ? product_area[PRODUCT_VERSION] : "Not Available"));
++	printf("Product Serial #    : %s\n",(product_area[PRODUCT_SERIAL][0] ? product_area[PRODUCT_SERIAL] : "Not Available"));
++	printf("Product Asset Tag   : %s\n",(product_area[PRODUCT_ASSET][0] ? product_area[PRODUCT_ASSET] : "Not Available"));
++	printf("Asset Tag Max Length: %d\n",asset_length);
++}
++
++int load_fru(int fd)
++{
++	FRU_COMMON_HEADER			*cmn_hdr;
++	FRU_AREA_INFO					inv_info_resp;
++	FRU_DATA_REQ_IPMI_10	data_req_10;
++	FRU_DATA_REQ_IPMI_09	data_req_09;
++	FRU_DATA_CHUNK				chunk;
++	IPMI_XFER							xfer;
++	IPMI_XFER							*xferp = &xfer;
++	unsigned char					fru_dev_id = 0x00, cc, *p, num, lang, *fru_buffer;
++	int										rc, fru_pos, brtl,i;
++	TL										*tl;
++
++	INIT_XFER(xferp);
++	SET_REQUEST_LUN(xferp, 0);
++	SET_REQUEST_NETFN(xferp, STORAGE_REQUEST);
++	SET_REQUEST_CMD(xferp,CMD_GET_FRU_INV_AREA_INFO);
++
++	if (dev_id.ipmi_version_major >= 1)
++		SET_REQUEST_DATA(xferp, &fru_dev_id, sizeof(fru_dev_id));
++
++	if ((rc = ioctl(fd, IOCTL_IPMI_XFER, (void *) &xfer))<0)
++		{
++		printf("load_fru(): failed (%m)\n");
++		return(-1);
++		}
++
++	GET_RESPONSE_CC(xferp, cc);
++	if (cc != 0x00)
++		{
++		printf("load_fru(): failed (cc = 0x%.2x)\n",cc);
++		return(-1);
++		}
++	memset(&inv_info_resp, 0, sizeof(inv_info_resp));
++	GET_RESPONSE_DATA(xferp, (unsigned char *) &inv_info_resp);
++	
++	fru_buffer = (unsigned char *) malloc(inv_info_resp.size);
++	memset(fru_buffer, 0, inv_info_resp.size);
++
++	brtl = inv_info_resp.size;
++	fru_pos = 0;
++	fru_size = inv_info_resp.size;
++	
++	while(brtl)
++		{
++		INIT_XFER(xferp);
++		SET_REQUEST_LUN(xferp, 0);
++		SET_REQUEST_NETFN(xferp, STORAGE_REQUEST);
++		SET_REQUEST_CMD(xferp, CMD_READ_FRU_INV_DATA);
++
++		if (dev_id.ipmi_version_major >= 1)
++			{
++			data_req_10.devid = 0x00;
++			data_req_10.offset = fru_pos;
++			if (brtl <=16)
++				data_req_10.count = brtl;
++			else
++				data_req_10.count = 16;
++			SET_REQUEST_DATA(xferp, &data_req_10, sizeof(data_req_10));
++			}
++		else
++			{
++			data_req_09.offset = fru_pos;
++			if (brtl <=16)
++				data_req_09.count = brtl;
++			else
++				data_req_09.count = 16;
++			SET_REQUEST_DATA(xferp, &data_req_09, sizeof(data_req_09));
++			}
++
++		if ((rc = ioctl(fd, IOCTL_IPMI_XFER, (void *) &xfer))<0)
++			{
++			printf("load_fru(): failed (%m)\n");
++			free(fru_buffer);
++			return(-1);
++			}
++		GET_RESPONSE_CC(xferp, cc);
++		if (cc != 0x00)
++			{
++			printf("load_fru(): failed (cc = 0x%.2x)\n",cc);
++			free(fru_buffer);
++			return(-1);
++			}
++		GET_RESPONSE_DATA(xferp, (unsigned char *) &chunk);
++		memcpy(&fru_buffer[fru_pos], &chunk.data[0], chunk.count);
++		brtl -=chunk.count;
++		fru_pos+=chunk.count;
++		}
++
++	cmn_hdr = (FRU_COMMON_HEADER *) fru_buffer;
++	if (cmn_hdr->board_area_offset)
++		{
++    p = &fru_buffer[(cmn_hdr->board_area_offset * 8)];
++    lang = p[2];
++    p +=6;
++    for (i=0; i < BOARD_AREA_NUM_FIELDS; i++)
++      {
++      tl = (TL *) p;
++      p++;
++      decode_string(tl->type_code, lang, p, board_area[i], tl->num_bytes);
++      board_area[i][tl->num_bytes] = 0;
++      p += tl->num_bytes;
++      }
++		}
++	if (cmn_hdr->product_info_offset)
++		{
++    p = &fru_buffer[(cmn_hdr->product_info_offset * 8)];
++    lang = p[2];
++    p +=3;
++
++    for (i=0; i < PRODUCT_AREA_NUM_FIELDS; i++)
++      {
++      tl = (TL *) p;
++      if (i == PRODUCT_ASSET)
++        {
++        asset_offset = (p - fru_buffer);
++        asset_length = tl->num_bytes;
++        asset_lang = lang;
++        }
++      p++;
++      decode_string(tl->type_code, lang, p, product_area[i], tl->num_bytes);
++      product_area[i][tl->num_bytes] = 0;
++      p += tl->num_bytes;
++      }
++		}
++#if 0
++  for (i=0; i < BOARD_AREA_NUM_FIELDS; i++)
++    printf("Field %d = %s\n",i,board_area[i]);
++  for (i=0; i < PRODUCT_AREA_NUM_FIELDS; i++)
++    printf("Field %d = %s\n",i,product_area[i]);
++#endif
++
++	free(fru_buffer);
++	return(0);
++}
++
++int set_asset(int fd, char *asset_tag)
++{
++	FRU_DATA_WRITE_REQ_IPMI_09	*wr_rq_09;
++	FRU_DATA_WRITE_REQ_IPMI_10	*wr_rq_10;
++	IPMI_XFER										xfer;
++	IPMI_XFER										*xferp = &xfer;
++	unsigned char								buffer[255], cc;
++	TL													*tl;
++	int													rc;
++
++	memset(buffer, 0, sizeof(buffer));
++
++	wr_rq_09 = (FRU_DATA_WRITE_REQ_IPMI_09 *) buffer;
++	wr_rq_10 = (FRU_DATA_WRITE_REQ_IPMI_10 *) buffer;
++
++	load_fru(fd);
++	if (asset_offset < 0)
++		return(-ELIBBAD);
++	if (strlen(asset_tag) > asset_length)
++		return (-EOVERFLOW);
++	INIT_XFER(xferp);
++	SET_REQUEST_LUN(xferp, 0);
++	SET_REQUEST_NETFN(xferp, STORAGE_REQUEST);
++	SET_REQUEST_CMD(xferp, CMD_WRITE_FRU_INV_DATA);
++	
++	if (dev_id.ipmi_version_major >= 1)
++		{
++		wr_rq_10->dev_id = 0x00;
++		wr_rq_10->offset = asset_offset;
++		tl = (TL *) &wr_rq_10->data[0];
++		tl->type_code = 0x03;
++		tl->num_bytes = asset_length;
++		memcpy(&wr_rq_10->data[1], asset_tag, strlen(asset_tag));
++		SET_REQUEST_DATA(xferp, wr_rq_10, (sizeof(FRU_DATA_WRITE_REQ_IPMI_09) + sizeof(TL) + asset_length));
++		}
++	else
++		{
++		wr_rq_09->offset = asset_offset;
++		tl = (TL *) &wr_rq_09->data[0];
++		tl->type_code = 0x03;
++		tl->num_bytes = asset_length;
++		memcpy(&wr_rq_09->data[1], asset_tag, strlen(asset_tag));
++		SET_REQUEST_DATA(xferp, wr_rq_09, (sizeof(FRU_DATA_WRITE_REQ_IPMI_09) + sizeof(TL) + asset_length));
++		}
++	if ((rc = ioctl(fd, IOCTL_IPMI_XFER, (void *) &xfer))<0)
++		{
++		printf("set_asset(): failed (%m)\n");
++		return(-1);
++		}
++	GET_RESPONSE_CC(xferp, cc);
++	if (cc != 0x00)
++		{
++		printf("set_asset(): failed (cc = 0x%.2x)\n",cc);
++		return(-1);
++		}
++	return(0);
++}
++
++#define STRING_DATA_TYPE_BINARY         0x00
++#define STRING_DATA_TYPE_BCD_PLUS       0x01
++#define STRING_DATA_TYPE_SIX_BIT_ASCII  0x02
++#define STRING_DATA_TYPE_LANG_DEPENDANT 0x03
++
++static void decode_string(unsigned char type,
++                          unsigned char language_code,
++                          unsigned char *source,
++                          char          *target,
++                          int           size)
++{
++  unsigned char *s = &source[0];
++  unsigned char *d = &target[0];
++ 
++  memset(target, 0, size);
++  if (type == STRING_DATA_TYPE_BCD_PLUS)
++    {
++    while(size)
++      {
++      if ((*s >= (unsigned char) 0x00) && (*s <= (unsigned char) 0x09))
++        *d++ = (unsigned char) 0x30 + (unsigned char) *s++;
++      else
++        {
++        if (*s == (unsigned char) 0x0A)
++          *d++ = (unsigned char) ' ';
++        else if (*s == (unsigned char) 0x0B)
++          *d++ = (unsigned char) '-';
++        else if (*s == (unsigned char) 0x0C)
++          *d++ = (unsigned char) '.';
++        else if ((*s <= (unsigned char) 0x0D) && (*s <= (unsigned char) 0x0F))
++          {
++          *d++ = (unsigned char) '*';
++          }
++        s++;
++        }
++      size --;
++      }
++    }
++  else if (type == STRING_DATA_TYPE_SIX_BIT_ASCII)
++    {
++    printf("Six bit ASCII decode not supported\n");
++    }
++  else if (type == STRING_DATA_TYPE_LANG_DEPENDANT)
++    {
++    if ((language_code == 0x00) || (language_code == 0x25) || (language_code == 0x19))
++      {
++      strncpy(target, source, size);
++      target[size] = 0x0;
++      }
++    else
++      {
++      printf("Language 0x%x dependant decode not supported\n",
++            language_code);
++      return;
++      }
++    }
++  else
++    {
++    printf("Unable to decode type 0x%.2x\n",type);
++    return;
++    }
++}
++
++
++/*
++ * General Purpose stuff
++ */
++void usage(char *progname)
++{
++	printf("Usage: %s [-r] [-s] [-p] [-d]\n",progname);
++	printf("       -r         -- report mainboard device ID\n");
++	printf("       -s         -- enable watchdog timer\n");
++	printf("       -p         -- pet watchdog timer\n");
++	printf("       -d         -- disable watchdog timer\n");
++	printf("       -q         -- query watchdog timer\n");
++	printf("       -f         -- display FRU \n");
++	printf("       -v         -- verbose driver info\n");
++	printf("       -a <tag>   -- set asset tag\n");
++	printf("       -b <state> -- set blink state (if supported)\n");
++}
+diff -urN linux-2.4.0.stock/ipmi_ctl.h linux-2.4.0/ipmi_ctl.h
+--- linux-2.4.0.stock/ipmi_ctl.h	Wed Dec 31 16:00:00 1969
++++ linux-2.4.0/ipmi_ctl.h	Fri Jan 26 21:42:34 2001
+@@ -0,0 +1,166 @@
++#ifndef _KCS_CTL_H
++#define _KCS_CTL_H
++
++typedef struct device_id_response
++  {
++  unsigned char device_id;
++
++  unsigned char device_revision         :4;
++  unsigned char reserved                :3;
++  unsigned char provides_sdr            :1;
++
++  unsigned char major_firmware_revision :7;
++  #define NORMAL_OPERATION  0
++  #define DEVICE_BUSY       1
++  unsigned char device_available        :1;
++
++  unsigned char minor_firmware_revision;
++
++  unsigned char ipmi_version_major      :4;
++  unsigned char ipmi_version_minor      :4;
++
++  unsigned char supports_sensor_device  :1;
++  unsigned char supports_sdr_device     :1;
++  unsigned char supports_sel_device     :1;
++  unsigned char supports_fru_device     :1;
++  unsigned char supports_ipmb_receiver  :1;
++  unsigned char supports_ipmb_generator :1;
++  unsigned char supports_bridge         :1;
++  unsigned char supports_chassis_device :1;
++
++  unsigned char manufacturer_id1;
++  unsigned char manufacturer_id2;
++  unsigned char manufacturer_id3;
++
++  unsigned short product_id;
++  } DEVICE_ID_RESPONSE;
++
++typedef struct set_watchdog
++  {
++  unsigned char timer_use         :3;
++  unsigned char res1              :4;
++  unsigned char dontlog           :1;
++  
++  unsigned char timeout_action    :3;
++  unsigned char res2              :1;
++  unsigned char pre_irq           :3;
++  unsigned char res3              :1;
++  
++  unsigned char pretimeout_interval;
++  
++  unsigned char tuefc_res1        :1;
++  unsigned char tuefc_biosfrb2    :1;
++  unsigned char tuefc_biospost    :1;
++  unsigned char tuefc_osload      :1;
++  unsigned char tuefc_smsos       :1;
++  unsigned char tuefc_oem         :1;
++  unsigned char tuefc_res2        :1;
++  unsigned char tuefc_res3        :1;
++  
++  unsigned short initial_count;
++  } SET_WATCHDOG;
++ 
++typedef struct get_watchdog_response
++  {
++  unsigned char timer_use    :3;
++  unsigned char res1         :3;
++  unsigned char timer_status :1;
++  unsigned char sel_log      :1;
++
++  unsigned char timeout_act  :3;
++  unsigned char res2         :1;
++  unsigned char pre_irq_act  :3;
++  unsigned char res3         :1;
++
++  unsigned char pre_timeout __attribute__ ((packed));
++
++  unsigned char timer_use_xp  __attribute__ ((packed));
++
++  unsigned short init_count  __attribute__ ((packed));
++  unsigned short current_count __attribute__ ((packed));
++  } GET_WATCHDOG_RESPONSE;
++
++#define BOARD_AREA_NUM_FIELDS  4
++#define BOARD_MANUFACTURER   0
++#define BOARD_PRODUCT_NAME   1
++#define BOARD_SERIAL         2
++#define BOARD_PART           3
++
++#define PRODUCT_AREA_NUM_FIELDS  6
++#define PRODUCT_MANUFACTURER   0
++#define PRODUCT_NAME           1
++#define PRODUCT_PART           2
++#define PRODUCT_VERSION        3
++#define PRODUCT_SERIAL         4
++#define PRODUCT_ASSET          5
++
++typedef struct kcs_fru_area_info
++  {
++  unsigned short  size  __attribute__ ((packed));
++
++#define ACCESSMODE_BYTE  0
++#define ACCESSMODE_WORD  1
++  unsigned char    accessmode:1;
++  unsigned char    reserved:7;
++  } FRU_AREA_INFO;
++
++typedef struct fru_data_req_ipmi_10
++  {
++	unsigned char		 devid	 __attribute__ ((packed));
++  unsigned short   offset  __attribute__ ((packed));
++  unsigned char    count    __attribute__ ((packed));
++  } FRU_DATA_REQ_IPMI_10;
++
++typedef struct fru_data_req_ipmi_09
++  {
++  unsigned short   offset  __attribute__ ((packed));
++  unsigned char    count    __attribute__ ((packed));
++  } FRU_DATA_REQ_IPMI_09;
++
++typedef struct fru_data_chunk
++	{
++	unsigned char	count;
++	unsigned char	data[16];
++	} FRU_DATA_CHUNK;
++
++typedef struct fru_data_write_req_ipmi_09
++	{
++	unsigned short	offset __attribute__((packed));
++	unsigned char		data[0];
++	} FRU_DATA_WRITE_REQ_IPMI_09;
++
++typedef struct fru_data_write_req_ipmi_10
++	{
++	unsigned char		dev_id __attribute__((packed));
++	unsigned short	offset __attribute__((packed));
++	unsigned char		data[0];
++	} FRU_DATA_WRITE_REQ_IPMI_10;
++
++typedef struct fru_common_header
++  {
++  unsigned char common_header_format_version;
++  unsigned char internal_use_offset;
++  unsigned char chassis_info_offset;
++  unsigned char board_area_offset;
++  unsigned char product_info_offset;
++  unsigned char multirecord_area_offset;
++  unsigned char pad;
++  unsigned char checksum;
++  } FRU_COMMON_HEADER;
++
++typedef struct type_length
++  {
++  unsigned char  num_bytes  :6;
++  unsigned char  type_code  :2;
++  } TL;
++
++#define CMD_GET_FRU_INV_AREA_INFO   0x10
++#define CMD_READ_FRU_INV_DATA       0x11
++#define CMD_WRITE_FRU_INV_DATA      0x12
++#define CMD_ADD_SEL_ENTRY           0x44
++#define CMD_WATCHDOG_SET            0x24
++#define CMD_WATCHDOG_GET            0x25
++#define CMD_WATCHDOG_RESET          0x22
++#define CMD_GET_DEVICE_ID           0x01
++
++#endif
--- ipmi-ctl-2.0.orig/debian/ipmi-control.postrm
+++ ipmi-ctl-2.0/debian/ipmi-control.postrm
@@ -0,0 +1,6 @@
+#!/bin/sh
+
+set -e
+
+update-modules
+
--- ipmi-ctl-2.0.orig/debian/ipmi-control.prerm
+++ ipmi-ctl-2.0/debian/ipmi-control.prerm
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+set -e
+pkg=ipmi-control
+
+if [ ! \( "$1" = "upgrade" -o "$1" = "remove" \) ] ; then
+	exit 0
+fi
+
+if [ -L /usr/doc/$pkg ] ; then
+	rm -f /usr/doc/$pkg
+fi
+
+exit 0
+
--- ipmi-ctl-2.0.orig/debian/kernel-patch-ipmi-kcs.postinst
+++ ipmi-ctl-2.0/debian/kernel-patch-ipmi-kcs.postinst
@@ -0,0 +1,16 @@
+#!/bin/sh
+
+set -e
+pkg=kernel-patch-ipmi-kcs
+
+if [ ! "$1" = "configure" ] ; then
+	exit 0
+fi
+
+
+if [ -d /usr/doc -a ! -e /usr/doc/$pkg -a -d /usr/share/doc/$pkg ] ; then
+	ln -s ../share/doc/$pkg /usr/doc/$pkg
+fi
+
+exit 0
+
--- ipmi-ctl-2.0.orig/debian/kernel-patch-ipmi-kcs.prerm
+++ ipmi-ctl-2.0/debian/kernel-patch-ipmi-kcs.prerm
@@ -0,0 +1,15 @@
+#!/bin/sh
+
+set -e
+pkg=kernel-patch-ipmi-kcs
+
+if [ ! \( "$1" = "upgrade" -o "$1" = "remove" \) ] ; then
+	exit 0
+fi
+
+if [ -L /usr/doc/$pkg ] ; then
+	rm -f /usr/doc/$pkg
+fi
+
+exit 0
+
--- ipmi-ctl-2.0.orig/debian/kernel-patch-ipmi-kcs.README
+++ ipmi-ctl-2.0/debian/kernel-patch-ipmi-kcs.README
@@ -0,0 +1,15 @@
+
+This package contains the kernel patches with IPMI KCS driver for the
+Linux kernel. It is made to be used for the make-kpkg tool from the
+kernel-package package, which makes it easy to build deb packages for
+Linux kernels.
+
+You can tell make-kpkg to apply this patch to you kernel either by
+setting the PATCH_THE_KERNEL environment variable to YES, or by using
+the "-added_patches ipmi-kcs" option to the commandline.  For complete
+information on make-kpkg see the make-kpkg(8) manpage.
+
+You can also apply the patch manually if wanted: the patches for 2.2 and
+2.4 kernels can be found in the /usr/src/kernel-patches/i386/ipmi-kcs/
+directory.
+
--- ipmi-ctl-2.0.orig/ipmi_ioctls.h
+++ ipmi-ctl-2.0/ipmi_ioctls.h
@@ -0,0 +1,152 @@
+/*
+ *  Intelligent Platform Management Interface driver for Linux 2.x
+ *
+ *  (c) Copyright 1999  San Mehat & VA Linux Systems
+ *        1382 Bordeaux Dr.
+ *        Sunnyvale, California
+ *        94089
+ *
+ *  http://www.valinux.com
+ *
+ *  This driver is provided under the GNU public license, incorporated
+ *  herein by reference. The driver is provided without warranty or
+ *  support.
+ *
+ *  IOCTL definitions for IPMI drivers
+ */
+
+/*
+ * Note: The following macros should be used on the IPMI_XFER structure.
+ *       DO NOT try to muck with this structure directly.. use the macros
+ *       to ensure future compatibility:
+ *
+ *  INIT_XFER(IPMI_XFER *);  
+ *    -- Zero out a IPMI_XFER structure and initialize it for use
+ *
+ *  SET_REQUEST_LUN(IPMI_XFER *, unsigned char lun);
+ *    -- Set the request packet logical unit
+ *
+ *  SET_REQUEST_NETFN(IPMI_XFER *, unsigned char netfn);
+ *    -- Set the request packet network function code
+ *
+ *  SET_REQUEST_CMD(IPMI_XFER *, unsigned char cmd);
+ *    -- Set the request packet IPMI command code
+ *
+ *  SET_REQUEST_DATA(IPMI_XFER *, unsigned char *data, int length);
+ *    -- Set the request packet optional argument data field
+ * 
+ *  GET_RESPONSE_LUN(IPMI_XFER *, unsigned char lun);
+ *    -- Get the response packet logical unit
+ *
+ *  GET_RESPONSE_NETFN(IPMI_XFER *, unsigned char netfn);
+ *    -- Get the response packet network function code
+ * 
+ *  GET_RESPONSE_CMD(IPMI_XFER *, unsigned char cmd);
+ *    -- Get the response packet command
+ *
+ *  GET_RESPONSE_CC(IPMI_XFER *, unsigned char cc);
+ *    -- Get the response packet completion code
+ * 
+ *  GET_RESPONSE_DATA_LENGTH(IPMI_XFER *, int len);
+ *    -- Get the response packet data length
+ * 
+ *  GET_RESPONSE_DATA(IPMI_XFER *, unsigned char *buffer);
+ *    -- Copy the response packet data into local buffer
+ */
+
+#ifndef _IPMI_IOCTLS_H
+#define _IPMI_IOCTLS_H
+
+#define	IOCTL_IPMI_XFER		0x01
+#define	IOCTL_DRIVER_INFO	0x02
+
+typedef struct ipmi_xfer
+	{
+	unsigned char	request[64];
+	unsigned char	response[64];
+	int						request_len;
+	int						response_len;
+	} IPMI_XFER;
+
+struct ipmi_driver_info
+	{
+	char						driver_name[64];			/* Name of the driver */
+	int							major_ver;					
+	int							minor_ver;
+	unsigned short	mb_chipset_vendor;		/* PCI host bridge vendor tag */
+	unsigned short	mb_chipset_device;		/* PCI host bridge vendor device id */
+	unsigned int		flags;								/* driver specific flags */
+	unsigned int		reserved;
+	};
+
+/* flags definitions for the 'ipmi_kcs' driver */
+#define KCS_FLAG_BLINKY	0x01	/* Set if blinky works (only on Intel L440GX) */
+#define KCS_FLAG_LEGACY	0x02  /* Set if using legacy KCS interface ( < IPMI 1.0) */
+
+#define INIT_XFER(_xferp) \
+	memset(_xferp, 0, sizeof(IPMI_XFER)); \
+	_xferp->request_len = 2; \
+	_xferp->response_len = sizeof(_xferp->response);
+
+#define SET_REQUEST_LUN(_xferp, _lun) \
+	{ \
+	unsigned char _netfn_copy; \
+	\
+	_netfn_copy = (_xferp->request[0] & 0xFC); \
+	_xferp->request[0] = _lun; \
+	_xferp->request[0]|= _netfn_copy; \
+	}
+
+#define SET_REQUEST_NETFN(_xferp, netfn) \
+	{ \
+	unsigned char __lun_copy; \
+	\
+	__lun_copy = (_xferp->request[0] & 0x3); \
+	_xferp->request[0] = (netfn << 2); \
+	_xferp->request[0]|= __lun_copy; \
+	}
+
+#define SET_REQUEST_CMD(_xferp, _cmd) \
+	_xferp->request[1] = _cmd;
+
+#define SET_REQUEST_DATA(_xferp, datap, _len) \
+	{ \
+	memcpy(&_xferp->request[2], datap, _len); \
+	_xferp->request_len = (_len + 2); \
+	}
+
+#define GET_RESPONSE_LUN(_xferp, _lun) \
+	_lun = (_xferp->response[0] & 0x3);
+
+#define GET_RESPONSE_NETFN(_xferp, netfn) \
+	netfn = ((_xferp->response[0] & 0xFC) >> 2);
+
+#define GET_RESPONSE_CMD(_xferp, _cmd) \
+	_cmd = _xferp->response[1];
+
+#define GET_RESPONSE_CC(_xferp, cc) \
+	cc = _xferp->response[2];
+
+#define GET_RESPONSE_DATA_LENGTH(_xferp, _len) \
+	_len = (_xferp->response_len - 3);
+
+#define GET_RESPONSE_DATA(_xferp, datap) \
+	memcpy(datap, &_xferp->response[3], (_xferp->response_len -3));
+
+/*
+ * The Netfn codes
+ */
+#define CHASSIS_REQUEST   0x00
+#define CHASSIS_RESPONSE  0x01
+#define BRIDGE_REQUEST    0x02
+#define BRIDGE_RESPONSE   0x03
+#define SENSOR_REQUEST    0x04
+#define SENSOR_RESPONSE   0x05
+#define APP_REQUEST       0x06
+#define APP_RESPONSE      0x07
+#define FIRMWARE_REQUEST  0x08
+#define FIRMWARE_RESPONSE 0x09
+#define STORAGE_REQUEST   0x0A
+#define STORAGE_RESPONSE  0x0B
+
+#endif
--- ipmi-ctl-2.0.orig/ipmi_ctl.8
+++ ipmi-ctl-2.0/ipmi_ctl.8
@@ -0,0 +1,60 @@
+.TH IPMI_CTL 8 "April 28, 2001" "VA Linux Systems" "IPMI control tools"
+.SH NAME
+ipmi_ctl \- IPMI management tool
+.SH SYNOPSIS
+.B ipmi_ctl [OPTIONS]
+.SH DESCRIPTION
+\fBipmi_ctl\fR is a command-line tool to perform various IPMI management
+functions from usermode. You need to have the IPMI KCS kernel driver
+loaded for this to work.
+.SH OPTIONS
+.TP
+.B \-s
+Report the mainboard device ID.
+.TP
+.B \-s
+Enable the system watchdog timer.
+.TP
+.B \-p
+Pet the watchdog timer.
+.TP
+.B \-d
+Disable the watchdog timer.
+.TP
+.B \-q
+Query the watchdog timer.
+.TP
+.B \-f
+Display FRU.
+.TP
+.B \-v
+Show verbose driver information.
+.TP
+.BI \-a <tag>
+Set the asset tag to \fI<tag>\fR.
+.TP
+.BI \-b <state>
+Set the blink state to \fI<state>\fR. Please note not all boards
+support this. \fI<state>\fR must be either 0 or 1.
+.TP
+.B \-i
+Retrieve sensor information.
+.TP
+.BI \-R <number>
+Display realtime sensor reading. If \fI<number>\fR is 0 enter an
+interactive shell, otherwise show the reading for the given sensor.
+.TP
+.B \-D
+Download the system event log.
+.TP
+.B \-C
+Clear the system event log.
+.SH FILES
+.nf
+.I /dev/ipmikcs
+.SH AUTHORS
+\fBipmi_ctl\fR was written by San Mehat, and is Copyright 1999 by
+San Mehat and VA Linux Systems.
+.P
+This manpage was written and is Copyright 2001 by Wichert Akkerman.
+
